{
  "paragraphs": [
    {
      "text": "%spark.dep\nz.load(\"org.opencypher:spark-cypher:0.3.2\")",
      "user": "anonymous",
      "dateUpdated": "2019-04-24 01:11:53.739",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/scala"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "res0: org.apache.zeppelin.dep.Dependency \u003d org.apache.zeppelin.dep.Dependency@7ad3c626\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1554817719835_309150500",
      "id": "20190409-154839_186784057",
      "dateCreated": "2019-04-09 15:48:39.835",
      "dateStarted": "2019-04-24 01:04:09.938",
      "dateFinished": "2019-04-24 01:04:18.474",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Imports and CAPS session",
      "text": "import org.opencypher.spark.api._\nimport org.opencypher.okapi.api.graph._\nimport org.opencypher.okapi.neo4j.io.Neo4jConfig\nimport java.net.URI\nimport org.opencypher.okapi.api.util.ZeppelinSupport._\nimport org.opencypher.spark.api.io.neo4j.sync.Neo4jGraphMerge\nimport org.opencypher.okapi.neo4j.io.MetaLabelSupport._\nimport org.opencypher.okapi.neo4j.io._\n\n// Create CAPS session\n  implicit val session: CAPSSession \u003d CAPSSession.local() //create(spark)",
      "user": "anonymous",
      "dateUpdated": "2019-04-24 01:04:23.459",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "mode": "table",
              "height": 318.9,
              "optionOpen": false
            }
          }
        },
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/scala",
        "title": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "import org.opencypher.spark.api._\nimport org.opencypher.okapi.api.graph._\nimport org.opencypher.okapi.neo4j.io.Neo4jConfig\nimport java.net.URI\nimport org.opencypher.okapi.api.util.ZeppelinSupport._\nimport org.opencypher.spark.api.io.neo4j.sync.Neo4jGraphMerge\nimport org.opencypher.okapi.neo4j.io.MetaLabelSupport._\nimport org.opencypher.okapi.neo4j.io._\nsession: org.opencypher.spark.api.CAPSSession \u003d CAPSSession\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1554818311686_-1260239771",
      "id": "20190409-155831_1352269553",
      "dateCreated": "2019-04-09 15:58:31.686",
      "dateStarted": "2019-04-24 01:04:23.519",
      "dateFinished": "2019-04-24 01:04:35.073",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%neo4j\nMATCH (n:Transaction)\nRETURN n\nLIMIT 50",
      "user": "anonymous",
      "dateUpdated": "2019-04-24 01:06:55.604",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "mode": "network",
              "height": 300.0,
              "optionOpen": false,
              "setting": {
                "table": {
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "names": {
                      "id": "string",
                      "label": "string",
                      "txid": "string"
                    },
                    "updated": false
                  },
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]",
                  "tableOptionValue": {
                    "useFilter": false,
                    "showPagination": false,
                    "showAggregationFooter": false
                  },
                  "updated": false,
                  "initialized": false
                }
              },
              "commonSetting": {}
            },
            "helium": {}
          }
        },
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/undefined"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "NETWORK",
            "data": "{\"nodes\":[{\"id\":272837,\"data\":{\"txid\":\"4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\"},\"label\":\"Transaction\"},{\"id\":272838,\"data\":{\"txid\":\"0e3e2357e806b6cdb1f70b54c3a3a17b6714ee1f0e68bebb44a74b1efd512098\"},\"label\":\"Transaction\"},{\"id\":272839,\"data\":{\"txid\":\"9b0fc92260312ce44e74ef369f5c66bbb85848f2eddd5a7a1cde251e54ccfdd5\"},\"label\":\"Transaction\"},{\"id\":272844,\"data\":{\"txid\":\"8aa673bc752f2851fd645d6a0a92917e967083007d9c1684f9423b100540673f\"},\"label\":\"Transaction\"},{\"id\":272845,\"data\":{\"txid\":\"a6f7f1c0dad0f2eb6b13c4f33de664b1b0e9f22efad5994a6d5b6086d85e85e3\"},\"label\":\"Transaction\"},{\"id\":272846,\"data\":{\"txid\":\"0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9\"},\"label\":\"Transaction\"},{\"id\":272847,\"data\":{\"txid\":\"d3ad39fa52a89997ac7381c95eeffeaf40b66af7a57e9eba144be0a175a12b11\"},\"label\":\"Transaction\"},{\"id\":272840,\"data\":{\"txid\":\"999e1c837c76a1b7fbb7e57baf87b309960f5ffefbf2a9b95dd890602272f644\"},\"label\":\"Transaction\"},{\"id\":272841,\"data\":{\"txid\":\"df2b060fa2e5e9c8ed5eaf6a45c13753ec8c63282b2688322eba40cd98ea067a\"},\"label\":\"Transaction\"},{\"id\":272842,\"data\":{\"txid\":\"63522845d294ee9b0188ae5cac91bf389a0c3723f084ca1025e7d9cdfe481ce1\"},\"label\":\"Transaction\"},{\"id\":272843,\"data\":{\"txid\":\"20251a76e64e920e58291a30d4b212939aae976baca40e70818ceaa596fb9d37\"},\"label\":\"Transaction\"},{\"id\":272852,\"data\":{\"txid\":\"50748b7a193a0b23f1e9494b51131d2f954cc6cf4792bacc69d207d16002080d\"},\"label\":\"Transaction\"},{\"id\":272853,\"data\":{\"txid\":\"e79fc1dad370e628614702f048edc8e98829cf8ea8f6615db19f992b1be92e44\"},\"label\":\"Transaction\"},{\"id\":272854,\"data\":{\"txid\":\"a3e0b7558e67f5cadd4a3166912cbf6f930044124358ef3a9afd885ac391625d\"},\"label\":\"Transaction\"},{\"id\":272855,\"data\":{\"txid\":\"f925f26deb2dc4696be8782ab7ad9493d04721b28ee69a09d7dfca51b863ca23\"},\"label\":\"Transaction\"},{\"id\":272848,\"data\":{\"txid\":\"f8325d8f7fa5d658ea143629288d0530d2710dc9193ddc067439de803c37066e\"},\"label\":\"Transaction\"},{\"id\":272849,\"data\":{\"txid\":\"3b96bb7e197ef276b85131afd4a09c059cc368133a26ca04ebffb0ab4f75c8b8\"},\"label\":\"Transaction\"},{\"id\":272850,\"data\":{\"txid\":\"9962d5c704ec27243364cbe9d384808feeac1c15c35ac790dffd1e929829b271\"},\"label\":\"Transaction\"},{\"id\":272851,\"data\":{\"txid\":\"e1afd89295b68bc5247fe0ca2885dd4b8818d7ce430faa615067d7bab8640156\"},\"label\":\"Transaction\"},{\"id\":272860,\"data\":{\"txid\":\"e1cf3476234d8446653ad52a8939ed792003eefdcd0e897319ab9d2cb4c14c8c\"},\"label\":\"Transaction\"},{\"id\":272861,\"data\":{\"txid\":\"43c39b8b3728c6cb26fae0fc18803ca6cf43e15fde218e3dfbd54e633cf6753e\"},\"label\":\"Transaction\"},{\"id\":272862,\"data\":{\"txid\":\"9b0f52332d7d013b49016416c4818b5abb80b01ca526b7b813830348ad2321be\"},\"label\":\"Transaction\"},{\"id\":272863,\"data\":{\"txid\":\"67c1e8143bb6ad221a4ce77d6c8be68f2e25e0743f51b2db1a7b22bab59014dc\"},\"label\":\"Transaction\"},{\"id\":272856,\"data\":{\"txid\":\"9b9e461221e5284f3bfe5656efdc8c7cc633b2f1beef54a86316bf2ae3a3e230\"},\"label\":\"Transaction\"},{\"id\":272857,\"data\":{\"txid\":\"ee1afca2d1130676503a6db5d6a77075b2bf71382cfdf99231f89717b5257b5b\"},\"label\":\"Transaction\"},{\"id\":272858,\"data\":{\"txid\":\"e0175970efb4417950921bfcba2a3a1e88c007c21232ff706009cc70b89210b4\"},\"label\":\"Transaction\"},{\"id\":272859,\"data\":{\"txid\":\"9e2eaf1d7e5178a2d116f331c340f1f7fd6de7540783ac36a7054fe9a4d64943\"},\"label\":\"Transaction\"},{\"id\":272868,\"data\":{\"txid\":\"86b33edba8ff663b0f73ef487e4433f34d26ef91de15659d2cc09594d27b52cb\"},\"label\":\"Transaction\"},{\"id\":272869,\"data\":{\"txid\":\"2b9905f06583c01454f10f720b5709e3b667c9dd3d9efc423c97b7e70afdc0c9\"},\"label\":\"Transaction\"},{\"id\":272870,\"data\":{\"txid\":\"bdeaa0089cd84670da5e6385f0185c2d7978bf57a1aa5540d3ff3b3eabaa1210\"},\"label\":\"Transaction\"},{\"id\":272871,\"data\":{\"txid\":\"223b0620a8f1c1f23a2ebf8032ed11321b921017d01974e74cddd651319b5474\"},\"label\":\"Transaction\"},{\"id\":272864,\"data\":{\"txid\":\"230cf03a6ce420eaa42e3c64feebb47920f3470efb4323b4574b4b6e5a004f65\"},\"label\":\"Transaction\"},{\"id\":272865,\"data\":{\"txid\":\"f399cb6c5bed7bb36d44f361c29dd5ecf12deba163470d8835b7ba0c4ed8aebd\"},\"label\":\"Transaction\"},{\"id\":272866,\"data\":{\"txid\":\"c361e2f4581f035dd58b99788347884e046e47b4c17ec347344ff8b24cd377ec\"},\"label\":\"Transaction\"},{\"id\":272867,\"data\":{\"txid\":\"f5e26c8b82401c585235c572ba8265f16f7d9304ed8e31c198eab571754f5331\"},\"label\":\"Transaction\"},{\"id\":272876,\"data\":{\"txid\":\"1484c18ba443b13851098597d8cb6d49d5983eab63c53d6b0dcc565612e7ca6b\"},\"label\":\"Transaction\"},{\"id\":272877,\"data\":{\"txid\":\"04391286b3aefbb5df4cdb515ac7fce7942525fa602e1d7757e90a4fd41a1e20\"},\"label\":\"Transaction\"},{\"id\":272878,\"data\":{\"txid\":\"9efa6cb3b8cca3c9387144f397f80e7b4bc2dd86026fdd308625a2e100a08d5a\"},\"label\":\"Transaction\"},{\"id\":272879,\"data\":{\"txid\":\"27c4d937dca276fb2b61e579902e8a876fd5b5abc17590410ced02d5a9f8e483\"},\"label\":\"Transaction\"},{\"id\":272872,\"data\":{\"txid\":\"852b1997ed935ba638078998e2d15bc8a91b8ad232e2d988e22c969eba3bafe0\"},\"label\":\"Transaction\"},{\"id\":272873,\"data\":{\"txid\":\"d05d256fbd5845b30039e37d48215788a4e438249048c47ddb9c83cd927d4d5a\"},\"label\":\"Transaction\"},{\"id\":272874,\"data\":{\"txid\":\"6d344eb5d67ed329a1c1d7603bba4b85d5916435b49f7a585bb370b76820287d\"},\"label\":\"Transaction\"},{\"id\":272875,\"data\":{\"txid\":\"e690daeb9f73d29d8a22cb4b5ec29970e9b32283d4376adeaad8691ccb449a68\"},\"label\":\"Transaction\"},{\"id\":272884,\"data\":{\"txid\":\"d17b9c9c609309049dfb9005edd7011f02d7875ca7dab6effddf4648bb70eff6\"},\"label\":\"Transaction\"},{\"id\":272885,\"data\":{\"txid\":\"32edede0b7d0c37340a665de057f418df634452f6bb80dcb8a5ff0aeddf1158a\"},\"label\":\"Transaction\"},{\"id\":272886,\"data\":{\"txid\":\"194c9715279d8626bc66f2b6552f2ae67b3df3a00b88553245b12bffffad5b59\"},\"label\":\"Transaction\"},{\"id\":272880,\"data\":{\"txid\":\"2f5c03ce19e9a855ac93087a1b68fe6592bcf4bd7cbb9c1ef264d886a785894e\"},\"label\":\"Transaction\"},{\"id\":272881,\"data\":{\"txid\":\"439aee1e1aa6923ad61c1990459f88de1faa3e18b4ee125f99b94b82e1e0af5f\"},\"label\":\"Transaction\"},{\"id\":272882,\"data\":{\"txid\":\"f69778085f1e78a1ea1cfcfe3b61ffb5c99870f5ae382e41ec43cf165d66a6d9\"},\"label\":\"Transaction\"},{\"id\":272883,\"data\":{\"txid\":\"ddd4d06365155ab4caaaee552fb3d8643207bd06efe14f920698a6dd4eb22ffa\"},\"label\":\"Transaction\"}],\"edges\":[],\"labels\":{\"Address\":\"#62EFA6\",\"Block\":\"#593BF9\",\"Transaction\":\"#B663BF\"},\"types\":[\"RECEIVES\",\"IS_BEFORE\",\"BELONGS_TO\",\"SENDS\"],\"directed\":true}"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1554818428133_1873437116",
      "id": "20190409-160028_416139935",
      "dateCreated": "2019-04-09 16:00:28.133",
      "dateStarted": "2019-04-24 01:06:55.646",
      "dateFinished": "2019-04-24 01:06:56.081",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%neo4j\nMATCH (a1:Address)-[r:SENDS]-\u003e(:Transaction)\u003c-[:SENDS]-(a2)\nRETURN a1.address, a2.address\nLIMIT 100",
      "user": "anonymous",
      "dateUpdated": "2019-04-24 01:10:32.664",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "mode": "table",
              "height": 300.0,
              "optionOpen": false,
              "setting": {
                "table": {
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "names": {
                      "a1.address": "string",
                      "a2.address": "string"
                    },
                    "updated": false
                  },
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]",
                  "tableOptionValue": {
                    "useFilter": false,
                    "showPagination": false,
                    "showAggregationFooter": false
                  },
                  "updated": false,
                  "initialized": false
                }
              },
              "commonSetting": {}
            },
            "helium": {}
          }
        },
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/undefined"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TABLE",
            "data": "a1.address\ta2.address\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1M6N5SPN5bUgoaYnyWchj9vmDq55ULfEF4\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"12e2ThtKdDMoUYsJNfNL6wRXQUv6UxvFMi\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1Q28WmLPxC2SmGJvX4EvnKwzuC15KJhJRK\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1MXqCyrFBj9Z7gJyDxvWXVcMX7bwhfREUL\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1EKftwK6eEFYGBXqbQ6oE1wY75nYg5PdZ4\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"14cNgVrCagmARSDMXTfYBx4sdXgGx8jKGX\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1HgjhW8EmE1vCvE1tdxGENajoFmvZVd31H\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1MqqhpnFGeVr9eNPXfuwPoLuYMUoZtmvzp\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1Bgsku62pqisYaaaHCwcYyHhTyFCdH2nGE\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1EuNjLzZhUf2qP6Kkg8m7GSEiQ6R4gFQe6\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"12M2criNN4SvWNAhPNztQEQUDhBtJHQSyP\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1AtUC7nykCa2HA5GNgXCjoeqTRvfX3hks4\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1KQdiDm2Bk4698xWQGrZQPDabPXNh5zN1Y\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1EtobpXeyYogrsFe1BvjDEh2sU1XtGE4Xa\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1Akf22AEf9xMy7HnUPSuC8zgJ836jJzp1z\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"142DfQVmPvCcM8AqF8ihsQFqWwnZCVA1kc\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1NqnW2EKWWAN75AoZzRU2BZ32YiDm9ag87\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"15ymL4LJQts1bvsq6aCNVUHzeod5bG4Zdy\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1FQJ3BezWbGUtFQcTyfckQJGQLQjkkpRPW\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1DQDVzHva4Qto56z4239CNNAJ6Ztr4R35Y\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1AQ9MXNwosuEU9Uzs9SeAjKBAWThjYrHas\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"19mzqERAvVLn77KtRNrodGqGoQaJGSuZhh\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"15vkfptyBdEgVtBG6svHENkhgVorBBsdPo\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"174fngq7FBttG4KecXFQHvdgHgTsQPRCdc\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1EUeiuGjBBVpHzMn7jTyV29Fvo5wmJW8So\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1KUK81BfE6j4CAgQkr1Qu9SdeD5tFUZsxD\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1jbSRLVrAQs6gLMDJh1iQeAsXxGJdnJvf\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"14JQwnhbHvu3XS8dsjYKgzvW8fz6u5rUDE\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1Kw7JAsh6jXJyZ6SeAKn2g8dfmW9MAYwhq\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"19E64fjvQQc4mzKfXXUMY5D3toHXJVHHG7\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1DpkWKjeMBphumK4mqCwncKVrYgEKWBKaM\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"12sXXas1SLKpJfMQboVdvQw1rkZHrukKWT\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"17UVYZpLtDPRBB6xKttui3DdTrbnp7xW9X\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1DrDFqv9aF1GDkGeQwMdULAb4m4tsNmh6W\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1FoMG4km6WmaG5ijj41FCw9PgT1Q5wSKpv\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1NvATn1Md41xCTDexmyYVqZsPZjFRtzEzm\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1FbhQjV1dxGTqTqmfPuEc9sTuxRxCVBiD3\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"13QKu5pneNgxZjmWvqorJu2qXinqEisZ8u\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1JSZaQyyXrp7jgwGsCx21Yx9PzT74uobn6\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"17vrynjK8vSLJoaMBa9oogRZkfKYN1F5R3\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"15bqSG4QBcAW9xMR3YHRqVqsf2K8ShNsR7\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1GtNf8gkVsffJTHyFWmJjDvvTG7p3DzDgu\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1LG2BrF5xg2RgnhusTNJp8s6ezpZxU6PK1\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"19FYHFC3UQMoWGC4SwzTPqVNPB11YwD34E\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"17AycLstKgAEVBM6wALv33LdJsZGprbqLd\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1HwhJ4AbkfnHzPmbyEUfkHTYMJCEyBwsrb\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"16PVj8oiif2YRaNACtw6nAvuou2ah8keZb\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"19HxgoH7TvHBFWyKSKDwpAntKJk6BDqc5f\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1LNysbJcbAxMK91fwQK6GrFDgHFWK4877f\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"15LUiCmfEwHPo1crometta9wzf4jnmvhzN\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1JPAwbDdDYAiWpC2836E4RHCEHrvXYTN44\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"16bcEU8ZSYjKKitMj7eUuKz4V27RnarL4s\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"18FojkcVCuTyHUJ4ddcJQ18RmnJY8kgznK\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1C2MRBLz2Cf6AujUBrhvDCZAFKmALuutEH\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"13Gqo4ebzbS9RNDnVBvF164nvC7jFa154h\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1nses1xLNvRwYjpfUEecnTbHETQSs41qF\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"17zcFQNzG2vp1k7p2EjC2dFUmbp81scXm4\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1CtSqqmpHqVZSgVwiidzSWaeeDVcDJkTLm\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1B7cfuUuwSYmo6THvX4iZzRxXecLVLCvEB\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1PfpJ1AidkiFEpocdXpuEFfyu5iGSWYujS\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"16tCxcuQiRd6xHoyt4otEu6AQQzJzAV4ky\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1G8ZRqUTtm5zvzGosfcwJnB4emVenGR7AH\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1B6XsHqzWUUBkhr8q8vmCLQrPbik49VnoP\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"12BjrUMvcMhxUkE7Ahhxfw8bSKqRusxFwu\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1KRUCty1LRGCeEvCtpsgL5vPpanvncsnB6\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1FdJeFm2pQbLherLAMeSZva5oM9ecVX6HG\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1LXu9JSV9tUz8Sr3M4CnAn8EMsNrV3WydM\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"16hZVSMLWAd58QcFpcB1QDsa5EyYFHXNbS\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1F4yKMDfVqCZSLrYXyNuQqtQcwEjAjRFNn\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1AVJgWfHdnR4u9h525mgmSQRs3QqUnqkFj\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1ADNs67REgC5WCMbG4EcLTKR7fYuSzi3SL\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"12Dy1ztphNpA1x9Ps6VatsGX7puRXPMfig\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1GPgK2iCBJj46kFMcFb9NVR93TYoDdVSdX\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1BBQLReqXL7b1RRiWcQUL11vGU8AY3ADWi\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1PYstnfuTCXdt3WfN79UBFbaYZCD6ERzPG\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1Cd1djBq9mkfy4BjyCS9VHiuJS8VWVD5Rg\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"18HDsDi73r7wLgxiCkEhZ7srhMcDLque7F\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"19eNtrwADhPHh7ip4qtggM76sqBJWYfZ6c\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1DNtFVe5g7B3cC4KsUBy6hvqKwjz7KhFUW\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"13aky2DAqNjQPiJJzDepSYYc8oMDSUhCuP\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1QE4ceMnLYsh4jBwDDU6p3LZjy5V5yF3YZ\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1NtvPVsgucdDwTXmLXT5muKh8MouvZzooq\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"17PBvEsFa9RckYBpAov8qYFJEohJBHVLso\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1EKJBybPUvi694PE8pRdazfYHMHDoEs5zE\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"194MyJdzS5j8T2Kmr6yU1D3ZXZDjHEoobn\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1PauoAZS3KFiXKruhvFioo3itdxi8DXjTa\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1PktYLRkTEGFy3JyfM9U64oSzkro75S2Jm\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"19UHQMxSxTGVkhnJtLPMAWbqPsxuVzz5UB\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"15kEK8srxqexjqxaqgYKEuC4ynTdv1X2o3\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"13BKnYGPQ3a7xiEgTJKxShG3ePRMDkUhh9\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1LQMCtSc8HiavpEizCXAQ23drEVRHFMNXG\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1Lsz86m2gzzfTdYKFb86yxqmcQ56y7NNAb\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1DjAvCdxLn4u2iyymWU11Qhg29PM5LHdYF\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"12wjmWY2mAxsHH82YWtKApzQmZqEYAW1cg\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1N2WhdGbZaEbRaCe4HSwYtk1tyFC4FNA52\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1PosstHaB1UysVqEDTn141TRse4AQTg3LV\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1MZPspoYqRDeS7yhbNe4xeCrJQns2ytRPU\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1PXqNzCmgeDqtcQVmQFZibbgEPa3A3rTh9\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"17SGEuEu2kDKwicUDNbW9HdYMceKX1wHC3\"\n\"111kzsNZ1w27kSGXwyov1ZvUGVLJMvLmJ\"\t\"1FWWHWRSkDgu4fzD4Kgq3Wa8U72Te6efo8\"\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1554818635635_-1701650630",
      "id": "20190409-160355_1164829756",
      "dateCreated": "2019-04-09 16:03:55.635",
      "dateStarted": "2019-04-24 01:10:32.196",
      "dateFinished": "2019-04-24 01:10:32.422",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%neo4j\nCALL dbms.procedures()",
      "user": "anonymous",
      "dateUpdated": "2019-04-10 14:19:27.661",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "mode": "table",
              "height": 300.0,
              "optionOpen": false,
              "setting": {
                "table": {
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "names": {
                      "name": "string",
                      "signature": "string",
                      "description": "string",
                      "roles": "string",
                      "mode": "string"
                    },
                    "updated": false
                  },
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]",
                  "tableOptionValue": {
                    "useFilter": false,
                    "showPagination": false,
                    "showAggregationFooter": false
                  },
                  "updated": false,
                  "initialized": false
                }
              },
              "commonSetting": {}
            }
          }
        },
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/undefined"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TABLE",
            "data": "name\tsignature\tdescription\troles\tmode\n\"apoc.algo.aStar\"\t\"apoc.algo.aStar(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, latPropertyName :: STRING?, lonPropertyName :: STRING?) :: (path :: PATH?, weight :: FLOAT?)\"\t\"apoc.algo.aStar(startNode, endNode, \u0027KNOWS|\u003cWORKS_WITH|IS_MANAGER_OF\u003e\u0027, \u0027distance\u0027,\u0027lat\u0027,\u0027lon\u0027) YIELD path, weight - run A* with relationship property name as cost function\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.algo.aStarConfig\"\t\"apoc.algo.aStarConfig(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, config :: MAP?) :: (path :: PATH?, weight :: FLOAT?)\"\t\"apoc.algo.aStar(startNode, endNode, \u0027KNOWS|\u003cWORKS_WITH|IS_MANAGER_OF\u003e\u0027, {weight:\u0027dist\u0027,default:10,x:\u0027lon\u0027,y:\u0027lat\u0027}) YIELD path, weight - run A* with relationship property name as cost function\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.algo.allSimplePaths\"\t\"apoc.algo.allSimplePaths(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, maxNodes :: INTEGER?) :: (path :: PATH?)\"\t\"apoc.algo.allSimplePaths(startNode, endNode, \u0027KNOWS|\u003cWORKS_WITH|IS_MANAGER_OF\u003e\u0027, 5) YIELD path, weight - run allSimplePaths with relationships given and maxNodes\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.algo.cliques\"\t\"apoc.algo.cliques(minSize :: NUMBER?) :: (clique :: LIST? OF NODE?)\"\t\"apoc.algo.cliques(minSize) YIELD cliques - search the graph and return all maximal cliques at least at large as the minimum size argument.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.algo.cliquesWithNode\"\t\"apoc.algo.cliquesWithNode(startNode :: NODE?, minSize :: NUMBER?) :: (clique :: LIST? OF NODE?)\"\t\"apoc.algo.cliquesWithNode(startNode, minSize) YIELD cliques - search the graph and return all maximal cliques that are at least as large than the minimum size argument and contain this node \"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.algo.community\"\t\"apoc.algo.community(times :: INTEGER?, labels :: LIST? OF STRING?, partitionKey :: STRING?, type :: STRING?, direction :: STRING?, weightKey :: STRING?, batchSize :: INTEGER?) :: VOID\"\t\"CALL apoc.algo.community(times,labels,partitionKey,type,direction,weightKey,batchSize) - simple label propagation kernel\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.algo.cover\"\t\"apoc.algo.cover(nodes :: ANY?) :: (rel :: RELATIONSHIP?)\"\t\"apoc.algo.cover(nodes) yield rel - returns all relationships between this set of nodes\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.algo.dijkstra\"\t\"apoc.algo.dijkstra(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, defaultWeight \u003d NaN :: FLOAT?, numberOfWantedPaths \u003d 1 :: INTEGER?) :: (path :: PATH?, weight :: FLOAT?)\"\t\"apoc.algo.dijkstra(startNode, endNode, \u0027KNOWS|\u003cWORKS_WITH|IS_MANAGER_OF\u003e\u0027, \u0027distance\u0027, defaultValue, numberOfWantedResults) YIELD path, weight - run dijkstra with relationship property name as cost function\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.algo.dijkstraWithDefaultWeight\"\t\"apoc.algo.dijkstraWithDefaultWeight(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, defaultWeight :: FLOAT?) :: (path :: PATH?, weight :: FLOAT?)\"\t\"apoc.algo.dijkstraWithDefaultWeight(startNode, endNode, \u0027KNOWS|\u003cWORKS_WITH|IS_MANAGER_OF\u003e\u0027, \u0027distance\u0027, 10) YIELD path, weight - run dijkstra with relationship property name as cost function and a default weight if the property does not exist\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.algo.pageRank\"\t\"apoc.algo.pageRank(nodes :: LIST? OF NODE?) :: (node :: NODE?, score :: FLOAT?)\"\t\"CALL apoc.algo.pageRank(nodes) YIELD node, score - calculates page rank for given nodes\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.algo.pageRankStats\"\t\"apoc.algo.pageRankStats(config :: MAP?) :: (nodes :: INTEGER?, relationships :: INTEGER?, iterations :: INTEGER?, readNodeMillis :: INTEGER?, readRelationshipMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, write :: BOOLEAN?, property :: STRING?)\"\t\"CALL apoc.algo.pageRankStats({iterations:_,types:_,write:true,...}) YIELD nodeCount - calculates page rank on graph  for given nodes and potentially writes back\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.algo.pageRankWithConfig\"\t\"apoc.algo.pageRankWithConfig(nodes :: LIST? OF NODE?, config :: MAP?) :: (node :: NODE?, score :: FLOAT?)\"\t\"CALL apoc.algo.pageRankWithConfig(nodes,{iterations:_,types:_}) YIELD node, score, info - calculates page rank for given nodes\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.algo.pageRankWithCypher\"\t\"apoc.algo.pageRankWithCypher(config :: MAP?) :: (nodes :: INTEGER?, relationships :: INTEGER?, iterations :: INTEGER?, readNodeMillis :: INTEGER?, readRelationshipMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, write :: BOOLEAN?, property :: STRING?)\"\t\"CALL apoc.algo.pageRankWithCypher({iterations,node_cypher,rel_cypher,write,property,numCpu}) - calculates page rank based on cypher input\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.algo.wcc\"\t\"apoc.algo.wcc() :: (nodeIds :: LIST? OF INTEGER?, stats :: MAP?)\"\t\"CALL apoc.algo.wcc() YIELD number of weakly connected components\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.atomic.add\"\t\"apoc.atomic.add(container :: ANY?, propertyName :: STRING?, number :: NUMBER?, times \u003d 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)\"\t\"apoc.atomic.add(node/relatonship,propertyName,number) Sums the property\u0027s value with the \u0027number\u0027 value \"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.atomic.concat\"\t\"apoc.atomic.concat(container :: ANY?, propertyName :: STRING?, string :: STRING?, times \u003d 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)\"\t\"apoc.atomic.concat(node/relatonship,propertyName,string) Concats the property\u0027s value with the \u0027string\u0027 value\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.atomic.insert\"\t\"apoc.atomic.insert(container :: ANY?, propertyName :: STRING?, position :: INTEGER?, value :: ANY?, times \u003d 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)\"\t\"apoc.atomic.insert(node/relatonship,propertyName,position,value) insert a value into the property\u0027s array value at \u0027position\u0027\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.atomic.remove\"\t\"apoc.atomic.remove(container :: ANY?, propertyName :: STRING?, position :: INTEGER?, times \u003d 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)\"\t\"apoc.atomic.remove(node/relatonship,propertyName,position) remove the element at position \u0027position\u0027\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.atomic.subtract\"\t\"apoc.atomic.subtract(container :: ANY?, propertyName :: STRING?, number :: NUMBER?, times \u003d 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)\"\t\"apoc.atomic.subtract(node/relatonship,propertyName,number) Subtracts the \u0027number\u0027 value to the property\u0027s value\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.atomic.update\"\t\"apoc.atomic.update(container :: ANY?, propertyName :: STRING?, operation :: STRING?, times \u003d 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)\"\t\"apoc.atomic.update(node/relatonship,propertyName,updateOperation) update a property\u0027s value with a cypher operation (ex. \\\"n.prop1+n.prop2\\\")\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.bolt.execute\"\t\"apoc.bolt.execute(url :: STRING?, kernelTransaction :: STRING?, params \u003d {} :: MAP?, config \u003d {} :: MAP?) :: (row :: MAP?)\"\t\"\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.bolt.load\"\t\"apoc.bolt.load(url :: STRING?, kernelTransaction :: STRING?, params \u003d {} :: MAP?, config \u003d {} :: MAP?) :: (row :: MAP?)\"\t\"\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.case\"\t\"apoc.case(conditionals :: LIST? OF ANY?, elseQuery \u003d  :: STRING?, params \u003d {} :: MAP?) :: (value :: MAP?)\"\t\"apoc.case([condition, query, condition, query, ...], elseQuery:\u0027\u0027, params:{}) yield value - given a list of conditional / read-only query pairs, executes the query associated with the first conditional evaluating to true (or the else query if none are true) with the given parameters\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.cluster.graph\"\t\"apoc.cluster.graph() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)\"\t\"\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.coll.elements\"\t\"apoc.coll.elements(values :: LIST? OF ANY?, limit \u003d -1 :: INTEGER?, offset \u003d 0 :: INTEGER?) :: (_1 :: ANY?, _2 :: ANY?, _3 :: ANY?, _4 :: ANY?, _5 :: ANY?, _6 :: ANY?, _7 :: ANY?, _8 :: ANY?, _9 :: ANY?, _10 :: ANY?, _1s :: STRING?, _2s :: STRING?, _3s :: STRING?, _4s :: STRING?, _5s :: STRING?, _6s :: STRING?, _7s :: STRING?, _8s :: STRING?, _9s :: STRING?, _10s :: STRING?, _1i :: INTEGER?, _2i :: INTEGER?, _3i :: INTEGER?, _4i :: INTEGER?, _5i :: INTEGER?, _6i :: INTEGER?, _7i :: INTEGER?, _8i :: INTEGER?, _9i :: INTEGER?, _10i :: INTEGER?, _1f :: FLOAT?, _2f :: FLOAT?, _3f :: FLOAT?, _4f :: FLOAT?, _5f :: FLOAT?, _6f :: FLOAT?, _7f :: FLOAT?, _8f :: FLOAT?, _9f :: FLOAT?, _10f :: FLOAT?, _1b :: BOOLEAN?, _2b :: BOOLEAN?, _3b :: BOOLEAN?, _4b :: BOOLEAN?, _5b :: BOOLEAN?, _6b :: BOOLEAN?, _7b :: BOOLEAN?, _8b :: BOOLEAN?, _9b :: BOOLEAN?, _10b :: BOOLEAN?, _1l :: LIST? OF ANY?, _2l :: LIST? OF ANY?, _3l :: LIST? OF ANY?, _4l :: LIST? OF ANY?, _5l :: LIST? OF ANY?, _6l :: LIST? OF ANY?, _7l :: LIST? OF ANY?, _8l :: LIST? OF ANY?, _9l :: LIST? OF ANY?, _10l :: LIST? OF ANY?, _1m :: MAP?, _2m :: MAP?, _3m :: MAP?, _4m :: MAP?, _5m :: MAP?, _6m :: MAP?, _7m :: MAP?, _8m :: MAP?, _9m :: MAP?, _10m :: MAP?, _1n :: NODE?, _2n :: NODE?, _3n :: NODE?, _4n :: NODE?, _5n :: NODE?, _6n :: NODE?, _7n :: NODE?, _8n :: NODE?, _9n :: NODE?, _10n :: NODE?, _1r :: RELATIONSHIP?, _2r :: RELATIONSHIP?, _3r :: RELATIONSHIP?, _4r :: RELATIONSHIP?, _5r :: RELATIONSHIP?, _6r :: RELATIONSHIP?, _7r :: RELATIONSHIP?, _8r :: RELATIONSHIP?, _9r :: RELATIONSHIP?, _10r :: RELATIONSHIP?, _1p :: PATH?, _2p :: PATH?, _3p :: PATH?, _4p :: PATH?, _5p :: PATH?, _6p :: PATH?, _7p :: PATH?, _8p :: PATH?, _9p :: PATH?, _10p :: PATH?, elements :: INTEGER?)\"\t\"apoc.coll.elements(list,limit,offset) yield _1,_2,..,_10,_1s,_2i,_3f,_4m,_5l,_6n,_7r,_8p - deconstruct subset of mixed list into identifiers of the correct type\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.coll.partition\"\t\"apoc.coll.partition(values :: LIST? OF ANY?, batchSize :: INTEGER?) :: (value :: LIST? OF ANY?)\"\t\"apoc.coll.partition(list,batchSize)\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.coll.split\"\t\"apoc.coll.split(values :: LIST? OF ANY?, value :: ANY?) :: (value :: LIST? OF ANY?)\"\t\"apoc.coll.split(list,value) | splits collection on given values rows of lists, value itself will not be part of resulting lists\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.coll.zipToRows\"\t\"apoc.coll.zipToRows(list1 :: LIST? OF ANY?, list2 :: LIST? OF ANY?) :: (value :: LIST? OF ANY?)\"\t\"apoc.coll.zipToRows(list1,list2) - creates pairs like zip but emits one row per pair\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.config.list\"\t\"apoc.config.list() :: (key :: STRING?, value :: ANY?)\"\t\"\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.config.map\"\t\"apoc.config.map() :: (value :: MAP?)\"\t\"\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.convert.setJsonProperty\"\t\"apoc.convert.setJsonProperty(node :: NODE?, key :: STRING?, value :: ANY?) :: VOID\"\t\"apoc.convert.setJsonProperty(node,key,complexValue) - sets value serialized to JSON as property with the given name on the node\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.convert.toTree\"\t\"apoc.convert.toTree(paths :: LIST? OF PATH?, lowerCaseRels \u003d true :: BOOLEAN?, config \u003d {} :: MAP?) :: (value :: MAP?)\"\t\"apoc.convert.toTree([paths],[lowerCaseRels\u003dtrue], [config]) creates a stream of nested documents representing the at least one root of these paths\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.couchbase.append\"\t\"apoc.couchbase.append(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)\"\t\"apoc.couchbase.append(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - append a couchbase json document to an existing one.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.couchbase.exists\"\t\"apoc.couchbase.exists(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?) :: (value :: BOOLEAN?)\"\t\"apoc.couchbase.exists(hostOrKey, bucket, documentId) yield value - check whether a couchbase json document with the given ID does exist.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.couchbase.get\"\t\"apoc.couchbase.get(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)\"\t\"apoc.couchbase.get(hostOrKey, bucket, documentId) yield id, expiry, cas, mutationToken, content - retrieves a couchbase json document by its unique ID.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.couchbase.insert\"\t\"apoc.couchbase.insert(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)\"\t\"apoc.couchbase.insert(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - insert a couchbase json document with its unique ID.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.couchbase.namedParamsQuery\"\t\"apoc.couchbase.namedParamsQuery(hostOrKey :: STRING?, bucket :: STRING?, statement :: STRING?, paramNames :: LIST? OF STRING?, paramValues :: LIST? OF ANY?) :: (queryResult :: LIST? OF MAP?)\"\t\"apoc.couchbase.namedParamsQuery(hostkOrKey, bucket, statement, paramNames, paramValues) yield queryResult - executes a N1QL statement with named parameters.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.couchbase.posParamsQuery\"\t\"apoc.couchbase.posParamsQuery(hostOrKey :: STRING?, bucket :: STRING?, statement :: STRING?, params :: LIST? OF ANY?) :: (queryResult :: LIST? OF MAP?)\"\t\"apoc.couchbase.posParamsQuery(hostOrKey, bucket, statement, params) yield queryResult - executes a N1QL statement with positional parameters.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.couchbase.prepend\"\t\"apoc.couchbase.prepend(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)\"\t\"apoc.couchbase.prepend(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - prepend a couchbase json document to an existing one.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.couchbase.query\"\t\"apoc.couchbase.query(hostOrKey :: STRING?, bucket :: STRING?, statement :: STRING?) :: (queryResult :: LIST? OF MAP?)\"\t\"apoc.couchbase.query(hostOrKey, bucket, statement) yield queryResult - executes a plain un-parameterized N1QL statement.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.couchbase.remove\"\t\"apoc.couchbase.remove(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)\"\t\"apoc.couchbase.remove(hostOrKey, bucket, documentId) yield id, expiry, cas, mutationToken, content - remove the couchbase json document identified by its unique ID.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.couchbase.replace\"\t\"apoc.couchbase.replace(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)\"\t\"apoc.couchbase.replace(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - replace the content of the couchbase json document identified by its unique ID.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.couchbase.upsert\"\t\"apoc.couchbase.upsert(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)\"\t\"apoc.couchbase.upsert(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - insert or overwrite a couchbase json document with its unique ID.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.create.addLabels\"\t\"apoc.create.addLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)\"\t\"apoc.create.addLabels( [node,id,ids,nodes], [\u0027Label\u0027,...]) - adds the given labels to the node or nodes\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.create.node\"\t\"apoc.create.node(label :: LIST? OF STRING?, props :: MAP?) :: (node :: NODE?)\"\t\"apoc.create.node([\u0027Label\u0027], {key:value,...}) - create node with dynamic labels\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.create.nodes\"\t\"apoc.create.nodes(label :: LIST? OF STRING?, props :: LIST? OF MAP?) :: (node :: NODE?)\"\t\"apoc.create.nodes([\u0027Label\u0027], [{key:value,...}]) create multiple nodes with dynamic labels\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.create.relationship\"\t\"apoc.create.relationship(from :: NODE?, relType :: STRING?, props :: MAP?, to :: NODE?) :: (rel :: RELATIONSHIP?)\"\t\"apoc.create.relationship(person1,\u0027KNOWS\u0027,{key:value,...}, person2) create relationship with dynamic rel-type\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.create.removeLabels\"\t\"apoc.create.removeLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)\"\t\"apoc.create.removeLabels( [node,id,ids,nodes], [\u0027Label\u0027,...]) - removes the given labels from the node or nodes\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.create.removeProperties\"\t\"apoc.create.removeProperties(nodes :: ANY?, keys :: LIST? OF STRING?) :: (node :: NODE?)\"\t\"apoc.create.removeProperties( [node,id,ids,nodes], [keys]) - removes the given property from the nodes(s)\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.create.removeRelProperties\"\t\"apoc.create.removeRelProperties(rels :: ANY?, keys :: LIST? OF STRING?) :: (rel :: RELATIONSHIP?)\"\t\"apoc.create.removeRelProperties( [rel,id,ids,rels], [keys], [values]) - removes the given property from the relationship(s)\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.create.setLabels\"\t\"apoc.create.setLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)\"\t\"apoc.create.setLabels( [node,id,ids,nodes], [\u0027Label\u0027,...]) - sets the given labels, non matching labels are removed on the node or nodes\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.create.setProperties\"\t\"apoc.create.setProperties(nodes :: ANY?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (node :: NODE?)\"\t\"apoc.create.setProperties( [node,id,ids,nodes], [keys], [values]) - sets the given property on the nodes(s)\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.create.setProperty\"\t\"apoc.create.setProperty(nodes :: ANY?, key :: STRING?, value :: ANY?) :: (node :: NODE?)\"\t\"apoc.create.setProperty( [node,id,ids,nodes], key, value) - sets the given property on the node(s)\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.create.setRelProperties\"\t\"apoc.create.setRelProperties(rels :: ANY?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (rel :: RELATIONSHIP?)\"\t\"apoc.create.setRelProperties( [rel,id,ids,rels], [keys], [values]) - sets the given property on the relationship(s)\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.create.setRelProperty\"\t\"apoc.create.setRelProperty(relationships :: ANY?, key :: STRING?, value :: ANY?) :: (rel :: RELATIONSHIP?)\"\t\"apoc.create.setRelProperty( [rel,id,ids,rels], key, value) - sets the given property on the relationship(s)\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.create.uuids\"\t\"apoc.create.uuids(count :: INTEGER?) :: (row :: INTEGER?, uuid :: STRING?)\"\t\"apoc.create.uuids(count) yield uuid - creates \u0027count\u0027 UUIDs \"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.create.vNode\"\t\"apoc.create.vNode(label :: LIST? OF STRING?, props :: MAP?) :: (node :: NODE?)\"\t\"apoc.create.vNode([\u0027Label\u0027], {key:value,...}) returns a virtual node\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.create.vNodes\"\t\"apoc.create.vNodes(label :: LIST? OF STRING?, props :: LIST? OF MAP?) :: (node :: NODE?)\"\t\"apoc.create.vNodes([\u0027Label\u0027], [{key:value,...}]) returns virtual nodes\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.create.vPattern\"\t\"apoc.create.vPattern(from :: MAP?, relType :: STRING?, props :: MAP?, to :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)\"\t\"apoc.create.vPattern({_labels:[\u0027LabelA\u0027],key:value},\u0027KNOWS\u0027,{key:value,...}, {_labels:[\u0027LabelB\u0027],key:value}) returns a virtual pattern\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.create.vPatternFull\"\t\"apoc.create.vPatternFull(labelsN :: LIST? OF STRING?, n :: MAP?, relType :: STRING?, props :: MAP?, labelsM :: LIST? OF STRING?, m :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)\"\t\"apoc.create.vPatternFull([\u0027LabelA\u0027],{key:value},\u0027KNOWS\u0027,{key:value,...},[\u0027LabelB\u0027],{key:value}) returns a virtual pattern\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.create.vRelationship\"\t\"apoc.create.vRelationship(from :: NODE?, relType :: STRING?, props :: MAP?, to :: NODE?) :: (rel :: RELATIONSHIP?)\"\t\"apoc.create.vRelationship(nodeFrom,\u0027KNOWS\u0027,{key:value,...}, nodeTo) returns a virtual relationship\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.custom.asFunction\"\t\"apoc.custom.asFunction(name :: STRING?, statement :: STRING?, outputs \u003d  :: STRING?, inputs \u003d null :: LIST? OF LIST? OF STRING?, forceSingle \u003d false :: BOOLEAN?) :: VOID\"\t\"\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.custom.asProcedure\"\t\"apoc.custom.asProcedure(name :: STRING?, statement :: STRING?, mode \u003d read :: STRING?, outputs \u003d null :: LIST? OF LIST? OF STRING?, inputs \u003d null :: LIST? OF LIST? OF STRING?) :: VOID\"\t\"\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.cypher.doIt\"\t\"apoc.cypher.doIt(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)\"\t\"apoc.cypher.doIt(fragment, params) yield value - executes writing fragment with the given parameters\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.cypher.mapParallel\"\t\"apoc.cypher.mapParallel(fragment :: STRING?, params :: MAP?, list :: LIST? OF ANY?) :: (value :: MAP?)\"\t\"apoc.cypher.mapParallel(fragment, params, list-to-parallelize) yield value - executes fragment in parallel batches with the list segments being assigned to _\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.cypher.mapParallel2\"\t\"apoc.cypher.mapParallel2(fragment :: STRING?, params :: MAP?, list :: LIST? OF ANY?, partitions :: INTEGER?, timeout \u003d 10 :: INTEGER?) :: (value :: MAP?)\"\t\"apoc.cypher.mapParallel2(fragment, params, list-to-parallelize) yield value - executes fragment in parallel batches with the list segments being assigned to _\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.cypher.parallel\"\t\"apoc.cypher.parallel(fragment :: STRING?, params :: MAP?, parallelizeOn :: STRING?) :: (value :: MAP?)\"\t\"\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.cypher.parallel2\"\t\"apoc.cypher.parallel2(fragment :: STRING?, params :: MAP?, parallelizeOn :: STRING?) :: (value :: MAP?)\"\t\"\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.cypher.run\"\t\"apoc.cypher.run(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)\"\t\"apoc.cypher.run(fragment, params) yield value - executes reading fragment with the given parameters\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.cypher.runFile\"\t\"apoc.cypher.runFile(file :: STRING?, config \u003d {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)\"\t\"apoc.cypher.runFile(file or url,[{statistics:true,timeout:10,parameters:{}}]) - runs each statement in the file, all semicolon separated - currently no schema operations\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.cypher.runFiles\"\t\"apoc.cypher.runFiles(file :: LIST? OF STRING?, config \u003d {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)\"\t\"apoc.cypher.runFiles([files or urls],[{statistics:true,timeout:10,parameters:{}}])) - runs each statement in the files, all semicolon separated\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.cypher.runMany\"\t\"apoc.cypher.runMany(cypher :: STRING?, params :: MAP?, config \u003d {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)\"\t\"apoc.cypher.runMany(\u0027cypher;\\nstatements;\u0027,{params},[{statistics:true,timeout:10}]) - runs each semicolon separated statement and returns summary - currently no schema operations\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.cypher.runSchemaFile\"\t\"apoc.cypher.runSchemaFile(file :: STRING?, config \u003d {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)\"\t\"apoc.cypher.runSchemaFile(file or url,[{statistics:true,timeout:10}]) - allows only schema operations, runs each schema statement in the file, all semicolon separated\"\t[\"architect\",\"admin\"]\t\"SCHEMA\"\n\"apoc.cypher.runSchemaFiles\"\t\"apoc.cypher.runSchemaFiles(file :: LIST? OF STRING?, config \u003d {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)\"\t\"apoc.cypher.runSchemaFiles([files or urls],{statistics:true,timeout:10}) - allows only schema operations, runs each schema statement in the files, all semicolon separated\"\t[\"architect\",\"admin\"]\t\"SCHEMA\"\n\"apoc.cypher.runTimeboxed\"\t\"apoc.cypher.runTimeboxed(cypher :: STRING?, params :: MAP?, timeout :: INTEGER?) :: (value :: MAP?)\"\t\"apoc.cypher.runTimeboxed(\u0027cypherStatement\u0027,{params}, timeout) - abort kernelTransaction after timeout ms if not finished\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.date.expire\"\t\"apoc.date.expire(node :: NODE?, time :: INTEGER?, timeUnit :: STRING?) :: VOID\"\t\"CALL apoc.date.expire(node,time,\u0027time-unit\u0027) - expire node in given time by setting :TTL label and `ttl` property\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.date.expireIn\"\t\"apoc.date.expireIn(node :: NODE?, timeDelta :: INTEGER?, timeUnit :: STRING?) :: VOID\"\t\"CALL apoc.date.expire.in(node,time,\u0027time-unit\u0027) - expire node in given time-delta by setting :TTL label and `ttl` property\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.do.case\"\t\"apoc.do.case(conditionals :: LIST? OF ANY?, elseQuery \u003d  :: STRING?, params \u003d {} :: MAP?) :: (value :: MAP?)\"\t\"apoc.do.case([condition, query, condition, query, ...], elseQuery:\u0027\u0027, params:{}) yield value - given a list of conditional / writing query pairs, executes the query associated with the first conditional evaluating to true (or the else query if none are true) with the given parameters\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.do.when\"\t\"apoc.do.when(condition :: BOOLEAN?, ifQuery :: STRING?, elseQuery \u003d  :: STRING?, params \u003d {} :: MAP?) :: (value :: MAP?)\"\t\"apoc.do.when(condition, ifQuery, elseQuery:\u0027\u0027, params:{}) yield value - based on the conditional, executes writing ifQuery or elseQuery with the given parameters\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.es.get\"\t\"apoc.es.get(host :: STRING?, index :: STRING?, type :: STRING?, id :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)\"\t\"apoc.es.get(host-or-port,index-or-null,type-or-null,id-or-null,query-or-null,payload-or-null) yield value - perform a GET operation on elastic search\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.es.getRaw\"\t\"apoc.es.getRaw(host :: STRING?, path :: STRING?, payload :: ANY?) :: (value :: MAP?)\"\t\"apoc.es.getRaw(host-or-port,path,payload-or-null) yield value - perform a raw GET operation on elastic search\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.es.post\"\t\"apoc.es.post(host :: STRING?, index :: STRING?, type :: STRING?, query :: ANY?, payload \u003d {} :: MAP?) :: (value :: MAP?)\"\t\"apoc.es.post(host-or-port,index-or-null,type-or-null,query-or-null,payload-or-null) yield value - perform a POST operation on elastic search\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.es.postRaw\"\t\"apoc.es.postRaw(host :: STRING?, path :: STRING?, payload :: ANY?) :: (value :: MAP?)\"\t\"apoc.es.postRaw(host-or-port,path,payload-or-null) yield value - perform a raw POST operation on elastic search\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.es.put\"\t\"apoc.es.put(host :: STRING?, index :: STRING?, type :: STRING?, id :: STRING?, query :: ANY?, payload \u003d {} :: MAP?) :: (value :: MAP?)\"\t\"apoc.es.put(host-or-port,index-or-null,type-or-null,id-or-null,query-or-null,payload-or-null) yield value - perform a PUT operation on elastic search\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.es.query\"\t\"apoc.es.query(host :: STRING?, index :: STRING?, type :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)\"\t\"apoc.es.query(host-or-port,index-or-null,type-or-null,query-or-null,payload-or-null) yield value - perform a SEARCH operation on elastic search\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.es.stats\"\t\"apoc.es.stats(host :: STRING?) :: (value :: MAP?)\"\t\"apoc.es.stats(host-url-Key) - elastic search statistics\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.example.movies\"\t\"apoc.example.movies() :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)\"\t\"apoc.example.movies() | Creates the sample movies graph\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.export.csv.all\"\t\"apoc.export.csv.all(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)\"\t\"\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.csv.data\"\t\"apoc.export.csv.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)\"\t\"\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.csv.graph\"\t\"apoc.export.csv.graph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)\"\t\"\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.csv.query\"\t\"apoc.export.csv.query(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)\"\t\"\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.cypher.all\"\t\"apoc.export.cypher.all(file \u003d  :: STRING?, config \u003d {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)\"\t\"apoc.export.cypher.all(file,config) - exports whole database incl. indexes as cypher statements to the provided file\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.cypher.data\"\t\"apoc.export.cypher.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file \u003d  :: STRING?, config \u003d {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)\"\t\"apoc.export.cypher.data(nodes,rels,file,config) - exports given nodes and relationships incl. indexes as cypher statements to the provided file\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.cypher.graph\"\t\"apoc.export.cypher.graph(graph :: MAP?, file \u003d  :: STRING?, config \u003d {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)\"\t\"apoc.export.cypher.graph(graph,file,config) - exports given graph object incl. indexes as cypher statements to the provided file\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.cypher.query\"\t\"apoc.export.cypher.query(query :: STRING?, file \u003d  :: STRING?, config \u003d {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)\"\t\"apoc.export.cypher.query(query,file,config) - exports nodes and relationships from the cypher statement incl. indexes as cypher statements to the provided file\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.cypher.schema\"\t\"apoc.export.cypher.schema(file \u003d  :: STRING?, config \u003d {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)\"\t\"apoc.export.cypher.schema(file,config) - exports all schema indexes and constraints to cypher\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.cypherAll\"\t\"apoc.export.cypherAll(file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)\"\t\"apoc.export.cypherAll(file,config) - exports whole database incl. indexes as cypher statements to the provided file\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.cypherData\"\t\"apoc.export.cypherData(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)\"\t\"apoc.export.cypherData(nodes,rels,file,config) - exports given nodes and relationships incl. indexes as cypher statements to the provided file\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.cypherGraph\"\t\"apoc.export.cypherGraph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)\"\t\"apoc.export.cypherGraph(graph,file,config) - exports given graph object incl. indexes as cypher statements to the provided file\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.cypherQuery\"\t\"apoc.export.cypherQuery(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)\"\t\"apoc.export.cypherQuery(query,file,config) - exports nodes and relationships from the cypher kernelTransaction incl. indexes as cypher statements to the provided file\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.graphml.all\"\t\"apoc.export.graphml.all(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)\"\t\"apoc.export.graphml.all(file,config) - exports whole database as graphml to the provided file\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.graphml.data\"\t\"apoc.export.graphml.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)\"\t\"apoc.export.graphml.data(nodes,rels,file,config) - exports given nodes and relationships as graphml to the provided file\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.graphml.graph\"\t\"apoc.export.graphml.graph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)\"\t\"apoc.export.graphml.graph(graph,file,config) - exports given graph object as graphml to the provided file\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.graphml.query\"\t\"apoc.export.graphml.query(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)\"\t\"apoc.export.graphml.query(query,file,config) - exports nodes and relationships from the cypher statement as graphml to the provided file\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.json.all\"\t\"apoc.export.json.all(file :: STRING?, config \u003d {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)\"\t\"\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.json.data\"\t\"apoc.export.json.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config \u003d {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)\"\t\"\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.json.graph\"\t\"apoc.export.json.graph(graph :: MAP?, file :: STRING?, config \u003d {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)\"\t\"\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.export.json.query\"\t\"apoc.export.json.query(query :: STRING?, file :: STRING?, config \u003d {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)\"\t\"\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.generate.ba\"\t\"apoc.generate.ba(noNodes :: INTEGER?, edgesPerNode :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID\"\t\"apoc.generate.ba(noNodes, edgesPerNode, label, type) - generates a random graph according to the Barabasi-Albert model\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.generate.complete\"\t\"apoc.generate.complete(noNodes :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID\"\t\"apoc.generate.complete(noNodes, label, type) - generates a random complete graph\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.generate.er\"\t\"apoc.generate.er(noNodes :: INTEGER?, noEdges :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID\"\t\"apoc.generate.er(noNodes, noEdges, label, type) - generates a random graph according to the Erdos-Renyi model\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.generate.simple\"\t\"apoc.generate.simple(degrees :: LIST? OF INTEGER?, label :: STRING?, type :: STRING?) :: VOID\"\t\"apoc.generate.simple(degrees, label, type) - generates a simple random graph according to the given degree distribution\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.generate.ws\"\t\"apoc.generate.ws(noNodes :: INTEGER?, degree :: INTEGER?, beta :: FLOAT?, label :: STRING?, type :: STRING?) :: VOID\"\t\"apoc.generate.ws(noNodes, degree, beta, label, type) - generates a random graph according to the Watts-Strogatz model\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.gephi.add\"\t\"apoc.gephi.add(urlOrKey :: STRING?, workspace :: STRING?, data :: ANY?, weightproperty \u003d null :: STRING?, exportproperties \u003d [] :: LIST? OF STRING?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)\"\t\"apoc.gephi.add(url-or-key, workspace, data, weightproperty, [\u0027exportproperty\u0027]) | streams passed in data to Gephi\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.get.nodes\"\t\"apoc.get.nodes(nodes :: ANY?) :: (node :: NODE?)\"\t\"apoc.get.nodes(node|id|[ids]) - quickly returns all nodes with these id\u0027s\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.get.rels\"\t\"apoc.get.rels(relationships :: ANY?) :: (rel :: RELATIONSHIP?)\"\t\"apoc.get.rels(rel|id|[ids]) - quickly returns all relationships with these id\u0027s\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.graph.from\"\t\"apoc.graph.from(data :: ANY?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)\"\t\"apoc.graph.from(data,\u0027name\u0027,{properties}) | creates a virtual graph object for later processing it tries its best to extract the graph information from the data you pass in\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.graph.fromCypher\"\t\"apoc.graph.fromCypher(kernelTransaction :: STRING?, params :: MAP?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)\"\t\"apoc.graph.fromCypher(\u0027kernelTransaction\u0027,{params},\u0027name\u0027,{properties}) - creates a virtual graph object for later processing\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.graph.fromDB\"\t\"apoc.graph.fromDB(name :: STRING?, properties :: MAP?) :: (graph :: MAP?)\"\t\"apoc.graph.fromDB(\u0027name\u0027,{properties}) - creates a virtual graph object for later processing\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.graph.fromData\"\t\"apoc.graph.fromData(nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)\"\t\"apoc.graph.fromData([nodes],[relationships],\u0027name\u0027,{properties}) | creates a virtual graph object for later processing\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.graph.fromPath\"\t\"apoc.graph.fromPath(path :: PATH?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)\"\t\"apoc.graph.fromPaths(path,\u0027name\u0027,{properties}) - creates a virtual graph object for later processing\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.graph.fromPaths\"\t\"apoc.graph.fromPaths(paths :: LIST? OF PATH?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)\"\t\"apoc.graph.fromPaths([paths],\u0027name\u0027,{properties}) - creates a virtual graph object for later processing\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.help\"\t\"apoc.help(proc :: STRING?) :: (type :: STRING?, name :: STRING?, text :: STRING?, signature :: STRING?, roles :: LIST? OF STRING?, writes :: BOOLEAN?)\"\t\"Provides descriptions of available procedures. To narrow the results, supply a search string. To also search in the description text, append + to the end of the search string.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.import.csv\"\t\"apoc.import.csv(nodes :: LIST? OF MAP?, relationships :: LIST? OF MAP?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)\"\t\"\"\t[\"architect\",\"admin\"]\t\"SCHEMA\"\n\"apoc.import.graphml\"\t\"apoc.import.graphml(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)\"\t\"apoc.import.graphml(file,config) - imports graphml file\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.index.addAllNodes\"\t\"apoc.index.addAllNodes(index :: STRING?, structure :: MAP?, options \u003d {} :: MAP?) :: (label :: STRING?, property :: STRING?, nodeCount :: INTEGER?)\"\t\"apoc.index.addAllNodes(\u0027name\u0027,{label1:[\u0027prop1\u0027,...],...}, {options}) YIELD type, name, config - create a free text search index\"\t[\"architect\",\"admin\"]\t\"SCHEMA\"\n\"apoc.index.addAllNodesExtended\"\t\"apoc.index.addAllNodesExtended(index :: STRING?, structure :: MAP?, options :: MAP?) :: (label :: STRING?, property :: STRING?, nodeCount :: INTEGER?)\"\t\"apoc.index.addAllNodesExtended(\u0027name\u0027,{label1:[\u0027prop1\u0027,...],...}, {options}) YIELD type, name, config - create a free text search index with special options\"\t[\"architect\",\"admin\"]\t\"SCHEMA\"\n\"apoc.index.addNode\"\t\"apoc.index.addNode(node :: NODE?, properties :: LIST? OF STRING?) :: VOID\"\t\"apoc.index.addNode(node,[\u0027prop1\u0027,...]) add node to an index for each label it has\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.index.addNodeByLabel\"\t\"apoc.index.addNodeByLabel(label :: STRING?, node :: NODE?, properties :: LIST? OF STRING?) :: VOID\"\t\"apoc.index.addNodeByLabel(node,\u0027Label\u0027,[\u0027prop1\u0027,...]) add node to an index for the given label\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.index.addNodeByName\"\t\"apoc.index.addNodeByName(name :: STRING?, node :: NODE?, properties :: LIST? OF STRING?) :: VOID\"\t\"apoc.index.addNodeByName(\u0027name\u0027,node,[\u0027prop1\u0027,...]) add node to an index for the given name\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.index.addNodeMap\"\t\"apoc.index.addNodeMap(node :: NODE?, properties :: MAP?) :: VOID\"\t\"apoc.index.addNodeMap(node,{key:value}) add node to an index for each label it has with the given attributes which can also be computed\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.index.addNodeMapByName\"\t\"apoc.index.addNodeMapByName(index :: STRING?, node :: NODE?, properties :: MAP?) :: VOID\"\t\"apoc.index.addNodeMapByName(index, node,{key:value}) add node to an index for each label it has with the given attributes which can also be computed\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.index.addRelationship\"\t\"apoc.index.addRelationship(relationship :: RELATIONSHIP?, properties :: LIST? OF STRING?) :: VOID\"\t\"apoc.index.addRelationship(rel,[\u0027prop1\u0027,...]) add relationship to an index for its type\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.index.addRelationshipByName\"\t\"apoc.index.addRelationshipByName(name :: STRING?, relationship :: RELATIONSHIP?, properties :: LIST? OF STRING?) :: VOID\"\t\"apoc.index.addRelationshipByName(\u0027name\u0027,rel,[\u0027prop1\u0027,...]) add relationship to an index for the given name\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.index.addRelationshipMap\"\t\"apoc.index.addRelationshipMap(relationship :: RELATIONSHIP?, docuemnt :: MAP?) :: VOID\"\t\"apoc.index.addRelationshipMap(rel,{key:value}) add relationship to an index for its type indexing the given document which can be computed\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.index.addRelationshipMapByName\"\t\"apoc.index.addRelationshipMapByName(index :: STRING?, relationship :: RELATIONSHIP?, docuemnt :: MAP?) :: VOID\"\t\"apoc.index.addRelationshipMapByName(index, rel,{key:value}) add relationship to an index for its type indexing the given document which can be computed\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.index.between\"\t\"apoc.index.between(from :: NODE?, type :: STRING?, to :: NODE?, query :: STRING?) :: (rel :: RELATIONSHIP?, weight :: FLOAT?, start :: NODE?, end :: NODE?)\"\t\"apoc.index.between(node1,\u0027TYPE\u0027,node2,\u0027prop:value*\u0027) YIELD rel - lucene query on relationship index with the given type name bound by either or both sides (each node parameter can be null)\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"READ\"\n\"apoc.index.forNodes\"\t\"apoc.index.forNodes(name :: STRING?, config \u003d {} :: MAP?) :: (type :: STRING?, name :: STRING?, config :: MAP?)\"\t\"apoc.index.forNodes(\u0027name\u0027,{config}) YIELD type,name,config - gets or creates node index\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.index.forRelationships\"\t\"apoc.index.forRelationships(name :: STRING?, config \u003d {} :: MAP?) :: (type :: STRING?, name :: STRING?, config :: MAP?)\"\t\"apoc.index.forRelationships(\u0027name\u0027,{config}) YIELD type,name,config - gets or creates relationship index\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.index.in\"\t\"apoc.index.in(to :: NODE?, type :: STRING?, query :: STRING?) :: (node :: NODE?, weight :: FLOAT?)\"\t\"apoc.index.in(node,\u0027TYPE\u0027,\u0027prop:value*\u0027) YIELD node lucene query on relationship index with the given type name for *incoming* relationship of the given node, *returns start-nodes*\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"READ\"\n\"apoc.index.list\"\t\"apoc.index.list() :: (type :: STRING?, name :: STRING?, config :: MAP?)\"\t\"apoc.index.list() - YIELD type,name,config - lists all manual indexes\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"READ\"\n\"apoc.index.nodes\"\t\"apoc.index.nodes(label :: STRING?, query :: STRING?) :: (node :: NODE?, weight :: FLOAT?)\"\t\"apoc.index.nodes(\u0027Label\u0027,\u0027prop:value*\u0027) YIELD node - lucene query on node index with the given label name\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"READ\"\n\"apoc.index.orderedByText\"\t\"apoc.index.orderedByText(label :: STRING?, key :: STRING?, operator :: STRING?, value :: STRING?, relevance :: BOOLEAN?, limit :: INTEGER?) :: (node :: NODE?)\"\t\"just use a cypher query with a range predicate on an indexed field and wait for index backed order by in 3.5\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.index.orderedRange\"\t\"apoc.index.orderedRange(label :: STRING?, key :: STRING?, min :: ANY?, max :: ANY?, relevance :: BOOLEAN?, limit :: INTEGER?) :: (node :: NODE?)\"\t\"deprecated, just there for compatibility. Use plain cypher instead\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.index.out\"\t\"apoc.index.out(from :: NODE?, type :: STRING?, query :: STRING?) :: (node :: NODE?, weight :: FLOAT?)\"\t\"out(node,\u0027TYPE\u0027,\u0027prop:value*\u0027) YIELD node - lucene query on relationship index with the given type name for *outgoing* relationship of the given node, *returns end-nodes*\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"READ\"\n\"apoc.index.related\"\t\"apoc.index.related(nodes :: LIST? OF NODE?, label :: STRING?, key :: STRING?, relationship :: STRING?, limit :: INTEGER?) :: (node :: NODE?)\"\t\"apoc.index.relatedNodes([nodes],label,key,\u0027\u003cTYPE\u0027/\u0027TYPE\u003e\u0027/\u0027TYPE\u0027,limit) yield node - schema range scan which keeps index order and adds limit and checks opposite node of relationship against the given set of nodes\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.index.relationships\"\t\"apoc.index.relationships(type :: STRING?, query :: STRING?) :: (rel :: RELATIONSHIP?, weight :: FLOAT?, start :: NODE?, end :: NODE?)\"\t\"apoc.index.relationships(\u0027TYPE\u0027,\u0027prop:value*\u0027) YIELD rel - lucene query on relationship index with the given type name\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"READ\"\n\"apoc.index.remove\"\t\"apoc.index.remove(name :: STRING?) :: (type :: STRING?, name :: STRING?, config :: MAP?)\"\t\"apoc.index.remove(\u0027name\u0027) YIELD type,name,config - removes an manual index\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.index.removeNodeByName\"\t\"apoc.index.removeNodeByName(name :: STRING?, node :: NODE?) :: VOID\"\t\"apoc.index.removeNodeByName(\u0027name\u0027,node) remove node from an index for the given name\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.index.removeRelationshipByName\"\t\"apoc.index.removeRelationshipByName(name :: STRING?, relationship :: RELATIONSHIP?) :: VOID\"\t\"apoc.index.removeRelationshipByName(\u0027name\u0027,rel) remove relationship from an index for the given name\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.index.search\"\t\"apoc.index.search(index :: STRING?, query :: STRING?, numberOfResults \u003d 100 :: INTEGER?) :: (node :: NODE?, weight :: FLOAT?)\"\t\"apoc.index.search(\u0027name\u0027, \u0027query\u0027, [maxNumberOfResults]) YIELD node, weight - search for nodes in the free text index matching the given query\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"READ\"\n\"apoc.load.csv\"\t\"apoc.load.csv(url :: STRING?, config \u003d {} :: MAP?) :: (lineNo :: INTEGER?, list :: LIST? OF ANY?, strings :: LIST? OF STRING?, map :: MAP?, stringMap :: MAP?)\"\t\"apoc.load.csv(\u0027url\u0027,{config}) YIELD lineNo, list, map - load CSV fom URL as stream of values,\n config contains any of: {skip:1,limit:5,header:false,sep:\u0027TAB\u0027,ignore:[\u0027tmp\u0027],nullValues:[\u0027na\u0027],arraySep:\u0027;\u0027,mapping:{years:{type:\u0027int\u0027,arraySep:\u0027-\u0027,array:false,name:\u0027age\u0027,ignore:false}}\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.load.driver\"\t\"apoc.load.driver(driverClass :: STRING?) :: VOID\"\t\"apoc.load.driver(\u0027org.apache.derby.jdbc.EmbeddedDriver\u0027) register JDBC driver of source database\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.load.html\"\t\"apoc.load.html(url :: STRING?, query \u003d {} :: MAP?, config \u003d {} :: MAP?) :: (value :: MAP?)\"\t\"apoc.load.html(\u0027url\u0027,{name: jquery, name2: jquery}, config) YIELD value - Load Html page and return the result as a Map\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.load.jdbc\"\t\"apoc.load.jdbc(jdbc :: STRING?, tableOrSql :: STRING?, params \u003d [] :: LIST? OF ANY?, config \u003d {} :: MAP?) :: (row :: MAP?)\"\t\"apoc.load.jdbc(\u0027key or url\u0027,\u0027table or statement\u0027, params, config) YIELD row - load from relational database, from a full table or a sql statement\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.load.jdbcParams\"\t\"apoc.load.jdbcParams(jdbc :: STRING?, sql :: STRING?, params :: LIST? OF ANY?, config \u003d {} :: MAP?) :: (row :: MAP?)\"\t\"deprecated - please use: apoc.load.jdbc(\u0027key or url\u0027,\u0027\u0027,[params]) YIELD row - load from relational database, from a sql statement with parameters\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.load.jdbcUpdate\"\t\"apoc.load.jdbcUpdate(jdbc :: STRING?, query :: STRING?, params \u003d [] :: LIST? OF ANY?, config \u003d {} :: MAP?) :: (row :: MAP?)\"\t\"apoc.load.jdbcUpdate(\u0027key or url\u0027,\u0027statement\u0027,[params],config) YIELD row - update relational database, from a SQL statement with optional parameters\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.load.json\"\t\"apoc.load.json(url :: STRING?, path \u003d  :: STRING?, config \u003d {} :: MAP?) :: (value :: MAP?)\"\t\"apoc.load.json(\u0027url\u0027,path, config) YIELD value -  import JSON as stream of values if the JSON was an array or a single value if it was a map\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.load.jsonArray\"\t\"apoc.load.jsonArray(url :: STRING?, path \u003d  :: STRING?) :: (value :: ANY?)\"\t\"apoc.load.jsonArray(\u0027url\u0027) YIELD value - load array from JSON URL (e.g. web-api) to import JSON as stream of values\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.load.jsonParams\"\t\"apoc.load.jsonParams(urlOrKey :: STRING?, headers :: MAP?, payload :: STRING?, path \u003d  :: STRING?, config \u003d {} :: MAP?) :: (value :: MAP?)\"\t\"apoc.load.jsonParams(\u0027url\u0027,{header:value},payload, config) YIELD value - load from JSON URL (e.g. web-api) while sending headers / payload to import JSON as stream of values if the JSON was an array or a single value if it was a map\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.load.ldap\"\t\"apoc.load.ldap(connection :: ANY?, search :: MAP?) :: (entry :: MAP?)\"\t\"apoc.load.ldap(\\\"key\\\" or {connectionMap},{searchMap}) Load entries from an ldap source (yield entry)\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"READ\"\n\"apoc.load.xml\"\t\"apoc.load.xml(url :: STRING?, path \u003d / :: STRING?, config \u003d {} :: MAP?, simple \u003d false :: BOOLEAN?) :: (value :: MAP?)\"\t\"apoc.load.xml(\u0027http://example.com/test.xml\u0027, \u0027xPath\u0027,config, false) YIELD value as doc CREATE (p:Person) SET p.name \u003d doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _childrenx fields.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.load.xmlSimple\"\t\"apoc.load.xmlSimple(url :: STRING?) :: (value :: MAP?)\"\t\"apoc.load.xmlSimple(\u0027http://example.com/test.xml\u0027) YIELD value as doc CREATE (p:Person) SET p.name \u003d doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _children fields. This method does intentionally not work with XML mixed content.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.lock.all\"\t\"apoc.lock.all(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?) :: VOID\"\t\"apoc.lock.all([nodes],[relationships]) acquires a write lock on the given nodes and relationships\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.lock.nodes\"\t\"apoc.lock.nodes(nodes :: LIST? OF NODE?) :: VOID\"\t\"apoc.lock.nodes([nodes]) acquires a write lock on the given nodes\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.lock.read.nodes\"\t\"apoc.lock.read.nodes(nodes :: LIST? OF NODE?) :: VOID\"\t\"apoc.lock.read.nodes([nodes]) acquires a read lock on the given nodes\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"READ\"\n\"apoc.lock.read.rels\"\t\"apoc.lock.read.rels(rels :: LIST? OF RELATIONSHIP?) :: VOID\"\t\"apoc.lock.read.rels([relationships]) acquires a read lock on the given relationship\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"READ\"\n\"apoc.lock.rels\"\t\"apoc.lock.rels(rels :: LIST? OF RELATIONSHIP?) :: VOID\"\t\"apoc.lock.rels([relationships]) acquires a write lock on the given relationship\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.log.debug\"\t\"apoc.log.debug(message :: STRING?, params \u003d {} :: MAP?) :: VOID\"\t\"apoc.log.debug(message, params) - logs debug message\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.log.error\"\t\"apoc.log.error(message :: STRING?, params \u003d {} :: MAP?) :: VOID\"\t\"apoc.log.error(message, params) - logs error message\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.log.info\"\t\"apoc.log.info(message :: STRING?, params \u003d {} :: MAP?) :: VOID\"\t\"apoc.log.info(message, params) - logs info message\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.log.stream\"\t\"apoc.log.stream(path :: STRING?, config \u003d {} :: MAP?) :: (lineNo :: INTEGER?, line :: STRING?, path :: STRING?)\"\t\"apoc.log.stream(\u0027neo4j.log\u0027, { last: n }) - retrieve log file contents, optionally return only the last n lines\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DBMS\"\n\"apoc.log.warn\"\t\"apoc.log.warn(message :: STRING?, params \u003d {} :: MAP?) :: VOID\"\t\"apoc.log.warn(message, params) - logs warn message\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.math.regr\"\t\"apoc.math.regr(label :: STRING?, propertyY :: STRING?, propertyX :: STRING?) :: (r2 :: FLOAT?, avgX :: FLOAT?, avgY :: FLOAT?, slope :: FLOAT?)\"\t\"apoc.math.regr(label, propertyY, propertyX) - It calculates the coefficient of determination (R-squared) for the values of propertyY and propertyX in the provided label\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"READ\"\n\"apoc.merge.node\"\t\"apoc.merge.node(label :: LIST? OF STRING?, identProps :: MAP?, props :: MAP?) :: (node :: NODE?)\"\t\"apoc.merge.node([\u0027Label\u0027], {key:value, ...}, {key:value,...}) - merge node with dynamic labels\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.merge.relationship\"\t\"apoc.merge.relationship(startNode :: NODE?, relationshipType :: STRING?, identProps :: MAP?, props :: MAP?, endNode :: NODE?) :: (rel :: RELATIONSHIP?)\"\t\"apoc.merge.relationship(startNode, relType,  {key:value, ...}, {key:value, ...}, endNode) - merge relationship with dynamic type\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.meta.data\"\t\"apoc.meta.data(config \u003d {} :: MAP?) :: (label :: STRING?, property :: STRING?, count :: INTEGER?, unique :: BOOLEAN?, index :: BOOLEAN?, existence :: BOOLEAN?, type :: STRING?, array :: BOOLEAN?, sample :: LIST? OF ANY?, leftCount :: INTEGER?, rightCount :: INTEGER?, left :: INTEGER?, right :: INTEGER?, other :: LIST? OF STRING?, otherLabels :: LIST? OF STRING?, elementType :: STRING?)\"\t\"apoc.meta.data({config})  - examines a subset of the graph to provide a tabular meta information\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.meta.graph\"\t\"apoc.meta.graph(config \u003d {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)\"\t\"apoc.meta.graph - examines the full graph to create the meta-graph\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.meta.graphSample\"\t\"apoc.meta.graphSample(config \u003d {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)\"\t\"apoc.meta.graphSample() - examines the database statistics to build the meta graph, very fast, might report extra relationships\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.meta.schema\"\t\"apoc.meta.schema(config \u003d {} :: MAP?) :: (value :: MAP?)\"\t\"apoc.meta.schema({config})  - examines a subset of the graph to provide a map-like meta information\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.meta.stats\"\t\"apoc.meta.stats() :: (labelCount :: INTEGER?, relTypeCount :: INTEGER?, propertyKeyCount :: INTEGER?, nodeCount :: INTEGER?, relCount :: INTEGER?, labels :: MAP?, relTypes :: MAP?, relTypesCount :: MAP?, stats :: MAP?)\"\t\"apoc.meta.stats  yield labelCount, relTypeCount, propertyKeyCount, nodeCount, relCount, labels, relTypes, stats | returns the information stored in the transactional database statistics\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.meta.subGraph\"\t\"apoc.meta.subGraph(config :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)\"\t\"apoc.meta.subGraph({labels:[labels],rels:[rel-types], excludes:[labels,rel-types]}) - examines a sample sub graph to create the meta-graph\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.metrics.get\"\t\"apoc.metrics.get(metricName :: STRING?, config \u003d {} :: MAP?) :: (timestamp :: INTEGER?, value :: FLOAT?, metric :: STRING?)\"\t\"apoc.metrics.get(metricName, {}) - retrieve a system metric by its metric name. Additional configuration options may be passed matching the options available for apoc.load.csv.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DBMS\"\n\"apoc.metrics.getClusterTimerMetric\"\t\"apoc.metrics.getClusterTimerMetric(metricName :: STRING?, config \u003d {} :: MAP?) :: (timestamp :: INTEGER?, count :: INTEGER?, max :: FLOAT?, mean :: FLOAT?, min :: FLOAT?, stddev :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p95 :: FLOAT?, p98 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, mean_rate :: FLOAT?, m1_rate :: FLOAT?, m5_rate :: FLOAT?, m15_rate :: FLOAT?, rate_unit :: STRING?, duration_unit :: STRING?)\"\t\"apoc.metrics.getClusterTimerMetric(metricName, {}) - retrieve a system metric by its metric name. This procedure is only intended for neo4j.causal_clustering.core.message_processing_timer.* metrics. Additional configuration options may be passed matching the options available for apoc.load.csv.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DBMS\"\n\"apoc.metrics.list\"\t\"apoc.metrics.list() :: (name :: STRING?, lastUpdated :: INTEGER?)\"\t\"apoc.metrics.list() - get a list of available metrics\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DBMS\"\n\"apoc.metrics.storage\"\t\"apoc.metrics.storage(directorySetting :: STRING?) :: (setting :: STRING?, freeSpaceBytes :: INTEGER?, totalSpaceBytes :: INTEGER?, usableSpaceBytes :: INTEGER?, percentFree :: FLOAT?)\"\t\"apoc.metrics.storage(directorySetting) - retrieve storage metrics about the devices Neo4j uses for data storage. directorySetting may be any valid neo4j directory setting name, such as \u0027dbms.directories.data\u0027.  If null is provided as a directorySetting, you will get back all available directory settings.  For a list of available directory settings, see the Neo4j operations manual reference on configuration settings.   Directory settings are **not** paths, they are a neo4j.conf setting key name\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DBMS\"\n\"apoc.model.jdbc\"\t\"apoc.model.jdbc(jdbc :: STRING?, config \u003d {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)\"\t\"apoc.model.jdbc(\u0027key or url\u0027, {schema:\u0027\u003cschema\u003e\u0027, write: \u003ctrue/false\u003e, filters: { tables:[], views: [], columns: []}) YIELD nodes, relationships - load schema from relational database\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.mongodb.count\"\t\"apoc.mongodb.count(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?) :: (value :: INTEGER?)\"\t\"apoc.mongodb.count(host-or-port,db-or-null,collection-or-null,query-or-null) yield value - perform a find operation on mongodb collection\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.mongodb.delete\"\t\"apoc.mongodb.delete(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?) :: (value :: INTEGER?)\"\t\"apoc.mongodb.delete(host-or-port,db-or-null,collection-or-null,list-of-maps) - delete the given documents from the mongodb collection and returns the number of affected documents\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.mongodb.find\"\t\"apoc.mongodb.find(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, project :: MAP?, sort :: MAP?, compatibleValues \u003d false :: BOOLEAN?, skip \u003d 0 :: INTEGER?, limit \u003d 0 :: INTEGER?) :: (value :: MAP?)\"\t\"apoc.mongodb.find(host-or-port,db-or-null,collection-or-null,query-or-null,projection-or-null,sort-or-null,pagination,[compatibleValues\u003dtrue|false],skip-or-null,limit-or-null) yield value - perform a find,project,sort operation on mongodb collection\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.mongodb.first\"\t\"apoc.mongodb.first(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, compatibleValues \u003d false :: BOOLEAN?) :: (value :: MAP?)\"\t\"apoc.mongodb.first(host-or-port,db-or-null,collection-or-null,query-or-null,[compatibleValues\u003dtrue|false]) yield value - perform a first operation on mongodb collection\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.mongodb.get\"\t\"apoc.mongodb.get(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, compatibleValues \u003d false :: BOOLEAN?, skip \u003d 0 :: INTEGER?, limit \u003d 0 :: INTEGER?) :: (value :: MAP?)\"\t\"apoc.mongodb.get(host-or-port,db-or-null,collection-or-null,query-or-null,[compatibleValues\u003dtrue|false],skip-or-null,limit-or-null) yield value - perform a find operation on mongodb collection\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.mongodb.insert\"\t\"apoc.mongodb.insert(host :: STRING?, db :: STRING?, collection :: STRING?, documents :: LIST? OF MAP?) :: VOID\"\t\"apoc.mongodb.insert(host-or-port,db-or-null,collection-or-null,list-of-maps) - inserts the given documents into the mongodb collection\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.mongodb.update\"\t\"apoc.mongodb.update(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, update :: MAP?) :: (value :: INTEGER?)\"\t\"apoc.mongodb.update(host-or-port,db-or-null,collection-or-null,list-of-maps) - updates the given documents from the mongodb collection and returns the number of affected documents\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.monitor.ids\"\t\"apoc.monitor.ids() :: (nodeIds :: INTEGER?, relIds :: INTEGER?, propIds :: INTEGER?, relTypeIds :: INTEGER?)\"\t\"apoc.monitor.ids() returns the object ids in use for this neo4j instance\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.monitor.kernel\"\t\"apoc.monitor.kernel() :: (readOnly :: BOOLEAN?, kernelVersion :: STRING?, storeId :: STRING?, kernelStartTime :: STRING?, databaseName :: STRING?, storeLogVersion :: INTEGER?, storeCreationDate :: STRING?)\"\t\"apoc.monitor.kernel() returns informations about the neo4j kernel\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.monitor.locks\"\t\"apoc.monitor.locks(minWaitTime :: INTEGER?) :: (advertedDeadLocks :: INTEGER?, lockCount :: INTEGER?, contendedLockCount :: INTEGER?, minimumWaitTimeMs :: INTEGER?, contendedLocks :: LIST? OF MAP?, info :: STRING?)\"\t\"deprecated, the information is not provided by neo4j anymore.\napoc.monitor.locks(minWaitTime) yield advertedDeadLocks, lockCount, contendedLockCount, minimumWaitTimeMs, contendedLocks, info\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.monitor.store\"\t\"apoc.monitor.store() :: (logSize :: INTEGER?, stringStoreSize :: INTEGER?, arrayStoreSize :: INTEGER?, relStoreSize :: INTEGER?, propStoreSize :: INTEGER?, totalStoreSize :: INTEGER?, nodeStoreSize :: INTEGER?)\"\t\"apoc.monitor.store() returns informations about the sizes of the different parts of the neo4j graph store\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.monitor.tx\"\t\"apoc.monitor.tx() :: (rolledBackTx :: INTEGER?, peakTx :: INTEGER?, lastTxId :: INTEGER?, currentOpenedTx :: INTEGER?, totalOpenedTx :: INTEGER?, totalTx :: INTEGER?)\"\t\"apoc.monitor.tx() returns informations about the neo4j transaction manager\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.neighbors.athop\"\t\"apoc.neighbors.athop(node :: NODE?, types \u003d  :: STRING?, distance \u003d 1 :: INTEGER?) :: (node :: NODE?)\"\t\"apoc.neighbors.athop(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at a distance, can use \u0027\u003e\u0027 or \u0027\u003c\u0027 for all outgoing or incoming relationships\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.neighbors.athop.count\"\t\"apoc.neighbors.athop.count(node :: NODE?, types \u003d  :: STRING?, distance \u003d 1 :: INTEGER?) :: (value :: INTEGER?)\"\t\"apoc.neighbors.athop.count(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at a distance, can use \u0027\u003e\u0027 or \u0027\u003c\u0027 for all outgoing or incoming relationships\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.neighbors.byhop\"\t\"apoc.neighbors.byhop(node :: NODE?, types \u003d  :: STRING?, distance \u003d 1 :: INTEGER?) :: (nodes :: LIST? OF NODE?)\"\t\"apoc.neighbors.byhop(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at each distance, can use \u0027\u003e\u0027 or \u0027\u003c\u0027 for all outgoing or incoming relationships\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.neighbors.byhop.count\"\t\"apoc.neighbors.byhop.count(node :: NODE?, types \u003d  :: STRING?, distance \u003d 1 :: INTEGER?) :: (value :: LIST? OF ANY?)\"\t\"apoc.neighbors.byhop.count(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at each distance, can use \u0027\u003e\u0027 or \u0027\u003c\u0027 for all outgoing or incoming relationships\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.neighbors.tohop\"\t\"apoc.neighbors.tohop(node :: NODE?, types \u003d  :: STRING?, distance \u003d 1 :: INTEGER?) :: (node :: NODE?)\"\t\"apoc.neighbors.tohop(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern up to a certain distance, can use \u0027\u003e\u0027 or \u0027\u003c\u0027 for all outgoing or incoming relationships\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.neighbors.tohop.count\"\t\"apoc.neighbors.tohop.count(node :: NODE?, types \u003d  :: STRING?, distance \u003d 1 :: INTEGER?) :: (value :: INTEGER?)\"\t\"apoc.neighbors.tohop.count(node, rel-direction-pattern, distance) - returns distinct count of nodes of the given relationships in the pattern up to a certain distance, can use \u0027\u003e\u0027 or \u0027\u003c\u0027 for all outgoing or incoming relationships\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.nodes.collapse\"\t\"apoc.nodes.collapse(nodes :: LIST? OF NODE?, config \u003d {} :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)\"\t\"apoc.nodes.collapse([nodes...],[{properties:\u0027overwrite\u0027 or \u0027discard\u0027 or \u0027combine\u0027}]) yield from, rel, to merge nodes onto first in list\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.nodes.delete\"\t\"apoc.nodes.delete(nodes :: ANY?, batchSize :: INTEGER?) :: (value :: INTEGER?)\"\t\"apoc.nodes.delete(node|nodes|id|[ids]) - quickly delete all nodes with these ids\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.nodes.get\"\t\"apoc.nodes.get(nodes :: ANY?) :: (node :: NODE?)\"\t\"apoc.nodes.get(node|nodes|id|[ids]) - quickly returns all nodes with these ids\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.nodes.group\"\t\"apoc.nodes.group(labels :: LIST? OF STRING?, groupByProperties :: LIST? OF STRING?, aggregations \u003d [{*\u003dcount}, {*\u003dcount}] :: LIST? OF MAP?, config \u003d {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?, node :: NODE?, relationship :: RELATIONSHIP?)\"\t\"\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.nodes.link\"\t\"apoc.nodes.link(nodes :: LIST? OF NODE?, type :: STRING?) :: VOID\"\t\"apoc.nodes.link([nodes],\u0027REL_TYPE\u0027) - creates a linked list of nodes from first to last\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.nodes.rels\"\t\"apoc.nodes.rels(relationships :: ANY?) :: (rel :: RELATIONSHIP?)\"\t\"apoc.get.rels(rel|id|[ids]) - quickly returns all relationships with these ids\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.path.expand\"\t\"apoc.path.expand(start :: ANY?, relationshipFilter :: STRING?, labelFilter :: STRING?, minLevel :: INTEGER?, maxLevel :: INTEGER?) :: (path :: PATH?)\"\t\"apoc.path.expand(startNode \u003cid\u003e|Node|list, \u0027TYPE|TYPE_OUT\u003e|\u003cTYPE_IN\u0027, \u0027+YesLabel|-NoLabel\u0027, minLevel, maxLevel ) yield path - expand from start node following the given relationships from min to max-level adhering to the label filters\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.path.expandConfig\"\t\"apoc.path.expandConfig(start :: ANY?, config :: MAP?) :: (path :: PATH?)\"\t\"apoc.path.expandConfig(startNode \u003cid\u003e|Node|list, {minLevel,maxLevel,uniqueness,relationshipFilter,labelFilter,uniqueness:\u0027RELATIONSHIP_PATH\u0027,bfs:true, filterStartNode:false, limit:-1, optional:false, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield path - expand from start node following the given relationships from min to max-level adhering to the label filters. \"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.path.spanningTree\"\t\"apoc.path.spanningTree(start :: ANY?, config :: MAP?) :: (path :: PATH?)\"\t\"apoc.path.spanningTree(startNode \u003cid\u003e|Node|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false, limit:-1, optional:false, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield path - expand a spanning tree reachable from start node following relationships to max-level adhering to the label filters\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.path.subgraphAll\"\t\"apoc.path.subgraphAll(start :: ANY?, config :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)\"\t\"apoc.path.subgraphAll(startNode \u003cid\u003e|Node|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false, limit:-1, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield nodes, relationships - expand the subgraph reachable from start node following relationships to max-level adhering to the label filters, and also return all relationships within the subgraph\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.path.subgraphNodes\"\t\"apoc.path.subgraphNodes(start :: ANY?, config :: MAP?) :: (node :: NODE?)\"\t\"apoc.path.subgraphNodes(startNode \u003cid\u003e|Node|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false, limit:-1, optional:false, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield node - expand the subgraph nodes reachable from start node following relationships to max-level adhering to the label filters\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.periodic.cancel\"\t\"apoc.periodic.cancel(name :: STRING?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)\"\t\"apoc.periodic.cancel(name) - cancel job with the given name\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.periodic.commit\"\t\"apoc.periodic.commit(statement :: STRING?, params \u003d {} :: MAP?) :: (updates :: INTEGER?, executions :: INTEGER?, runtime :: INTEGER?, batches :: INTEGER?, failedBatches :: INTEGER?, batchErrors :: MAP?, failedCommits :: INTEGER?, commitErrors :: MAP?, wasTerminated :: BOOLEAN?)\"\t\"apoc.periodic.commit(statement,params) - runs the given statement in separate transactions until it returns 0\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.periodic.countdown\"\t\"apoc.periodic.countdown(name :: STRING?, statement :: STRING?, rate :: INTEGER?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)\"\t\"apoc.periodic.countdown(\u0027name\u0027,statement,repeat-rate-in-seconds) submit a repeatedly-called background statement until it returns 0\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.periodic.iterate\"\t\"apoc.periodic.iterate(cypherIterate :: STRING?, cypherAction :: STRING?, config :: MAP?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, wasTerminated :: BOOLEAN?)\"\t\"apoc.periodic.iterate(\u0027statement returning items\u0027, \u0027statement per item\u0027, {batchSize:1000,iterateList:true,parallel:false,params:{},concurrency:50,retries:0}) YIELD batches, total - run the second statement for each item returned by the first statement. Returns number of batches and total processed rows\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.periodic.list\"\t\"apoc.periodic.list() :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)\"\t\"apoc.periodic.list - list all jobs\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.periodic.repeat\"\t\"apoc.periodic.repeat(name :: STRING?, statement :: STRING?, rate :: INTEGER?, config \u003d {} :: MAP?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)\"\t\"apoc.periodic.repeat(\u0027name\u0027,statement,repeat-rate-in-seconds, config) submit a repeatedly-called background statement. Fourth parameter \u0027config\u0027 is optional and can contain \u0027params\u0027 entry for nested statement.\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.periodic.rock_n_roll\"\t\"apoc.periodic.rock_n_roll(cypherIterate :: STRING?, cypherAction :: STRING?, batchSize :: INTEGER?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, wasTerminated :: BOOLEAN?)\"\t\"apoc.periodic.rock_n_roll(\u0027some cypher for iteration\u0027, \u0027some cypher as action on each iteration\u0027, 10000) YIELD batches, total - run the action statement in batches over the iterator statement\u0027s results in a separate thread. Returns number of batches and total processed rows\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.periodic.rock_n_roll_while\"\t\"apoc.periodic.rock_n_roll_while(cypherLoop :: STRING?, cypherIterate :: STRING?, cypherAction :: STRING?, batchSize :: INTEGER?) :: (loop :: ANY?, batches :: INTEGER?, total :: INTEGER?)\"\t\"apoc.periodic.rock_n_roll_while(\u0027some cypher for knowing when to stop\u0027, \u0027some cypher for iteration\u0027, \u0027some cypher as action on each iteration\u0027, 10000) YIELD batches, total - run the action statement in batches over the iterator statement\u0027s results in a separate thread. Returns number of batches and total processed rows\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.periodic.submit\"\t\"apoc.periodic.submit(name :: STRING?, statement :: STRING?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)\"\t\"apoc.periodic.submit(\u0027name\u0027,statement) - submit a one-off background statement\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.refactor.categorize\"\t\"apoc.refactor.categorize(sourceKey :: STRING?, type :: STRING?, outgoing :: BOOLEAN?, label :: STRING?, targetKey :: STRING?, copiedKeys :: LIST? OF STRING?, batchSize :: INTEGER?) :: VOID\"\t\"apoc.refactor.categorize(sourceKey, type, outgoing, label, targetKey, copiedKeys, batchSize) turn each unique propertyKey into a category node and connect to it\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.refactor.cloneNodes\"\t\"apoc.refactor.cloneNodes(nodes :: LIST? OF NODE?, withRelationships \u003d false :: BOOLEAN?, skipProperties \u003d [] :: LIST? OF STRING?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)\"\t\"apoc.refactor.cloneNodes([node1,node2,...]) clone nodes with their labels and properties\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.refactor.cloneNodesWithRelationships\"\t\"apoc.refactor.cloneNodesWithRelationships(nodes :: LIST? OF NODE?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)\"\t\"apoc.refactor.cloneNodesWithRelationships([node1,node2,...]) clone nodes with their labels, properties and relationships\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.refactor.cloneSubgraph\"\t\"apoc.refactor.cloneSubgraph(nodes :: LIST? OF NODE?, rels \u003d [] :: LIST? OF RELATIONSHIP?, config \u003d {} :: MAP?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)\"\t\"apoc.refactor.cloneSubgraph([node1,node2,...], [rel1,rel2,...]:[], {standinNodes:[], skipProperties:[]}) YIELD input, output, error | clone nodes with their labels and properties (optionally skipping any properties in the skipProperties list via the config map), and clone the given relationships (will exist between cloned nodes only). If no relationships are provided, all relationships between the given nodes will be cloned. Relationships can be optionally redirected according to standinNodes node pairings (this is a list of list-pairs of nodes), so given a node in the original subgraph (first of the pair), an existing node (second of the pair) can act as a standin for it within the cloned subgraph. Cloned relationships will be redirected to the standin.\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.refactor.cloneSubgraphFromPaths\"\t\"apoc.refactor.cloneSubgraphFromPaths(paths :: LIST? OF PATH?, config \u003d {} :: MAP?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)\"\t\"apoc.refactor.cloneSubgraphFromPaths([path1, path2, ...], {standinNodes:[], skipProperties:[]}) YIELD input, output, error | from the subgraph formed from the given paths, clone nodes with their labels and properties (optionally skipping any properties in the skipProperties list via the config map), and clone the relationships (will exist between cloned nodes only). Relationships can be optionally redirected according to standinNodes node pairings (this is a list of list-pairs of nodes), so given a node in the original subgraph (first of the pair), an existing node (second of the pair) can act as a standin for it within the cloned subgraph. Cloned relationships will be redirected to the standin.\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.refactor.collapseNode\"\t\"apoc.refactor.collapseNode(nodes :: ANY?, type :: STRING?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)\"\t\"apoc.refactor.collapseNode([node1,node2],\u0027TYPE\u0027) collapse node to relationship, node with one rel becomes self-relationship\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.refactor.extractNode\"\t\"apoc.refactor.extractNode(relationships :: ANY?, labels :: LIST? OF STRING?, outType :: STRING?, inType :: STRING?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)\"\t\"apoc.refactor.extractNode([rel1,rel2,...], [labels],\u0027OUT\u0027,\u0027IN\u0027) extract node from relationships\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.refactor.from\"\t\"apoc.refactor.from(relationship :: RELATIONSHIP?, newNode :: NODE?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)\"\t\"apoc.refactor.from(rel, startNode) redirect relationship to use new start-node\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.refactor.invert\"\t\"apoc.refactor.invert(relationship :: RELATIONSHIP?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)\"\t\"apoc.refactor.invert(rel) inverts relationship direction\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.refactor.mergeNodes\"\t\"apoc.refactor.mergeNodes(nodes :: LIST? OF NODE?, config \u003d {} :: MAP?) :: (node :: NODE?)\"\t\"apoc.refactor.mergeNodes([node1,node2],[{properties:\u0027overwrite\u0027 or \u0027discard\u0027 or \u0027combine\u0027}]) merge nodes onto first in list\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.refactor.mergeRelationships\"\t\"apoc.refactor.mergeRelationships(rels :: LIST? OF RELATIONSHIP?, config \u003d {} :: MAP?) :: (rel :: RELATIONSHIP?)\"\t\"apoc.refactor.mergeRelationships([rel1,rel2]) merge relationships onto first in list\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.refactor.normalizeAsBoolean\"\t\"apoc.refactor.normalizeAsBoolean(entity :: ANY?, propertyKey :: STRING?, true_values :: LIST? OF ANY?, false_values :: LIST? OF ANY?) :: VOID\"\t\"apoc.refactor.normalizeAsBoolean(entity, propertyKey, true_values, false_values) normalize/convert a property to be boolean\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.refactor.rename.label\"\t\"apoc.refactor.rename.label(oldLabel :: STRING?, newLabel :: STRING?, nodes \u003d [] :: LIST? OF NODE?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)\"\t\"apoc.refactor.rename.label(oldLabel, newLabel, [nodes]) | rename a label from \u0027oldLabel\u0027 to \u0027newLabel\u0027 for all nodes. If \u0027nodes\u0027 is provided renaming is applied to this set only\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.refactor.rename.nodeProperty\"\t\"apoc.refactor.rename.nodeProperty(oldName :: STRING?, newName :: STRING?, nodes \u003d [] :: LIST? OF ANY?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)\"\t\"apoc.refactor.rename.nodeProperty(oldName, newName, [nodes]) | rename all node\u0027s property from \u0027oldName\u0027 to \u0027newName\u0027. If \u0027nodes\u0027 is provided renaming is applied to this set only\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.refactor.rename.type\"\t\"apoc.refactor.rename.type(oldType :: STRING?, newType :: STRING?, rels \u003d [] :: LIST? OF RELATIONSHIP?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)\"\t\"apoc.refactor.rename.type(oldType, newType, [rels]) | rename all relationships with type \u0027oldType\u0027 to \u0027newType\u0027. If \u0027rels\u0027 is provided renaming is applied to this set only\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.refactor.rename.typeProperty\"\t\"apoc.refactor.rename.typeProperty(oldName :: STRING?, newName :: STRING?, rels \u003d [] :: LIST? OF ANY?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)\"\t\"apoc.refactor.rename.typeProperty(oldName, newName, [rels]) | rename all relationship\u0027s property from \u0027oldName\u0027 to \u0027newName\u0027. If \u0027rels\u0027 is provided renaming is applied to this set only\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.refactor.setType\"\t\"apoc.refactor.setType(relationship :: RELATIONSHIP?, newType :: STRING?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)\"\t\"apoc.refactor.setType(rel, \u0027NEW-TYPE\u0027) change relationship-type\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.refactor.to\"\t\"apoc.refactor.to(relationship :: RELATIONSHIP?, newNode :: NODE?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)\"\t\"apoc.refactor.to(rel, endNode) redirect relationship to use new end-node\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.schema.assert\"\t\"apoc.schema.assert(indexes :: MAP?, constraints :: MAP?, dropExisting \u003d true :: BOOLEAN?) :: (label :: STRING?, key :: STRING?, keys :: LIST? OF STRING?, unique :: BOOLEAN?, action :: STRING?)\"\t\"apoc.schema.assert({indexLabel:[[indexKeys]], ...}, {constraintLabel:[constraintKeys], ...}, dropExisting : true) yield label, key, keys, unique, action - drops all other existing indexes and constraints when `dropExisting` is `true` (default is `true`), and asserts that at the end of the operation the given indexes and unique constraints are there, each label:key pair is considered one constraint/label. Non-constraint indexes can define compound indexes with label:[key1,key2...] pairings.\"\t[\"architect\",\"admin\"]\t\"SCHEMA\"\n\"apoc.schema.nodes\"\t\"apoc.schema.nodes(config \u003d {} :: MAP?) :: (name :: STRING?, label :: STRING?, properties :: LIST? OF STRING?, status :: STRING?, type :: STRING?, failure :: STRING?, populationProgress :: FLOAT?, size :: INTEGER?, valuesSelectivity :: FLOAT?, userDescription :: STRING?)\"\t\"CALL apoc.schema.nodes([config]) yield name, label, properties, status, type\"\t[\"architect\",\"admin\"]\t\"SCHEMA\"\n\"apoc.schema.properties.distinct\"\t\"apoc.schema.properties.distinct(label :: STRING?, key :: STRING?) :: (value :: LIST? OF ANY?)\"\t\"apoc.schema.properties.distinct(label, key) - quickly returns all distinct values for a given key\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.schema.properties.distinctCount\"\t\"apoc.schema.properties.distinctCount(label \u003d  :: STRING?, key \u003d  :: STRING?) :: (label :: STRING?, key :: STRING?, value :: ANY?, count :: INTEGER?)\"\t\"apoc.schema.properties.distinctCount([label], [key]) YIELD label, key, value, count - quickly returns all distinct values and counts for a given key\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.schema.relationships\"\t\"apoc.schema.relationships(config \u003d {} :: MAP?) :: (name :: STRING?, type :: STRING?, properties :: LIST? OF STRING?, status :: STRING?)\"\t\"CALL apoc.schema.relationships([config]) yield name, startLabel, type, endLabel, properties, status\"\t[\"architect\",\"admin\"]\t\"SCHEMA\"\n\"apoc.search.multiSearchReduced\"\t\"apoc.search.multiSearchReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)\"\t\"Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched properties. apoc.search.multiSearchReduced( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ). Multiple search results for the same node are merged into one record.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.search.node\"\t\"apoc.search.node(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (node :: NODE?)\"\t\"Do a parallel search over multiple indexes returning nodes. usage apoc.search.node( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ) returns all the DISTINCT Nodes found in the different searches.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.search.nodeAll\"\t\"apoc.search.nodeAll(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (node :: NODE?)\"\t\"Do a parallel search over multiple indexes returning nodes. usage apoc.search.nodeAll( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ) returns all the Nodes found in the different searches.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.search.nodeAllReduced\"\t\"apoc.search.nodeAllReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: ANY?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)\"\t\"Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched property. apoc.search.nodeShortAll( map of label and properties which will be searched upon, operator: EXACT / CONTAINS / STARTS WITH | ENDS WITH /\u003d / \u003c\u003e / \u003c / \u003e ..., value ). All \u0027hits\u0027 are returned.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.search.nodeReduced\"\t\"apoc.search.nodeReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)\"\t\"Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched properties. apoc.search.nodeReduced( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ). Multiple search results for the same node are merged into one record.\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.spatial.geocode\"\t\"apoc.spatial.geocode(location :: STRING?, maxResults \u003d 100 :: INTEGER?, quotaException \u003d false :: BOOLEAN?) :: (location :: MAP?, data :: MAP?, latitude :: FLOAT?, longitude :: FLOAT?, description :: STRING?)\"\t\"apoc.spatial.geocode(\u0027address\u0027) YIELD location, latitude, longitude, description, osmData - look up geographic location of address from a geocoding service (the default one is OpenStreetMap)\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.spatial.geocodeOnce\"\t\"apoc.spatial.geocodeOnce(location :: STRING?) :: (location :: MAP?, data :: MAP?, latitude :: FLOAT?, longitude :: FLOAT?, description :: STRING?)\"\t\"apoc.spatial.geocodeOnce(\u0027address\u0027) YIELD location, latitude, longitude, description, osmData - look up geographic location of address from a geocoding service (the default one is OpenStreetMap)\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.spatial.reverseGeocode\"\t\"apoc.spatial.reverseGeocode(latitude :: FLOAT?, longitude :: FLOAT?, quotaException \u003d false :: BOOLEAN?) :: (location :: MAP?, data :: MAP?, latitude :: FLOAT?, longitude :: FLOAT?, description :: STRING?)\"\t\"apoc.spatial.reverseGeocode(latitude,longitude) YIELD location, latitude, longitude, description - look up address from latitude and longitude from a geocoding service (the default one is OpenStreetMap)\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.spatial.sortByDistance\"\t\"apoc.spatial.sortByDistance(paths :: LIST? OF PATH?) :: (path :: PATH?, distance :: FLOAT?)\"\t\"apoc.spatial.sortPathsByDistance(List\u003cPath\u003e) sort the given paths based on the geo informations (lat/long) in ascending order\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.static.get\"\t\"apoc.static.get(key :: STRING?) :: (value :: ANY?)\"\t\"apoc.static.get(name) - returns statically stored value from config (apoc.static.\u003ckey\u003e) or server lifetime storage\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.static.getAll\"\t\"apoc.static.getAll(prefix :: STRING?) :: (value :: MAP?)\"\t\"apoc.static.getAll(prefix) - returns statically stored values from config (apoc.static.\u003cprefix\u003e.*) or server lifetime storage\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.static.list\"\t\"apoc.static.list(prefix :: STRING?) :: (key :: STRING?, value :: ANY?)\"\t\"apoc.static.list(prefix) - returns statically stored values from config (apoc.static.\u003cprefix\u003e.*) or server lifetime storage\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.static.set\"\t\"apoc.static.set(key :: STRING?, value :: ANY?) :: (value :: ANY?)\"\t\"apoc.static.set(name, value) - stores value under key for server livetime storage, returns previously stored or configured value\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.stats.degrees\"\t\"apoc.stats.degrees(types \u003d  :: STRING?) :: (type :: STRING?, direction :: STRING?, total :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p999 :: INTEGER?, max :: INTEGER?, min :: INTEGER?, mean :: FLOAT?)\"\t\"\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.text.doubleMetaphone\"\t\"apoc.text.doubleMetaphone(value :: ANY?) :: (value :: STRING?)\"\t\"apoc.text.doubleMetaphone(value) yield value - Compute the Double Metaphone phonetic encoding of all words of the text value which can be a single string or a list of strings\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.text.phonetic\"\t\"apoc.text.phonetic(value :: ANY?) :: (value :: STRING?)\"\t\"apoc.text.phonetic(value) yield value - Compute the US_ENGLISH phonetic soundex encoding of all words of the text value which can be a single string or a list of strings\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.text.phoneticDelta\"\t\"apoc.text.phoneticDelta(text1 :: STRING?, text2 :: STRING?) :: (phonetic1 :: STRING?, phonetic2 :: STRING?, delta :: INTEGER?)\"\t\"apoc.text.phoneticDelta(text1, text2) yield phonetic1, phonetic2, delta - Compute the US_ENGLISH soundex character difference between two given strings\"\t[\"reader\",\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"DEFAULT\"\n\"apoc.trigger.add\"\t\"apoc.trigger.add(name :: STRING?, kernelTransaction :: STRING?, selector :: MAP?, config \u003d {} :: MAP?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)\"\t\"\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.trigger.list\"\t\"apoc.trigger.list() :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)\"\t\"\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.trigger.pause\"\t\"apoc.trigger.pause(name :: STRING?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)\"\t\"\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.trigger.remove\"\t\"apoc.trigger.remove(name :: STRING?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)\"\t\"\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\"\n\"apoc.trigger.removeAll\"\t\"apoc.trigger.removeAll() :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)\"\t\"\"\t[\"editor\",\"publisher\",\"architect\",\"admin\"]\t\"WRITE\""
          },
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"result-alert alert-warning\" role\u003d\"alert\"\u003e\u003cbutton type\u003d\"button\" class\u003d\"close\" data-dismiss\u003d\"alert\" aria-label\u003d\"Close\"\u003e\u003cspan aria-hidden\u003d\"true\"\u003e\u0026times;\u003c/span\u003e\u003c/button\u003e\u003cstrong\u003eOutput is truncated\u003c/strong\u003e to 102400 bytes. Learn more about \u003cstrong\u003eZEPPELIN_INTERPRETER_OUTPUT_LIMIT\u003c/strong\u003e\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1554898743794_-1816440768",
      "id": "20190410-141903_1714941131",
      "dateCreated": "2019-04-10 14:19:03.794",
      "dateStarted": "2019-04-10 14:19:22.815",
      "dateFinished": "2019-04-10 14:19:25.887",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%neo4j\nCALL db.relationshipTypes()",
      "user": "anonymous",
      "dateUpdated": "2019-04-10 15:23:54.328",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "mode": "table",
              "height": 300.0,
              "optionOpen": false,
              "setting": {
                "table": {
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "names": {
                      "relationshipType": "string"
                    },
                    "updated": false
                  },
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]",
                  "tableOptionValue": {
                    "useFilter": false,
                    "showPagination": false,
                    "showAggregationFooter": false
                  },
                  "updated": false,
                  "initialized": false
                }
              },
              "commonSetting": {}
            }
          }
        },
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/undefined"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TABLE",
            "data": "relationshipType\n\"IS_BEFORE\"\n\"BELONGS_TO\"\n\"RECEIVES\"\n\"SENDS\"\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1554899481758_1057075835",
      "id": "20190410-143121_956912726",
      "dateCreated": "2019-04-10 14:31:21.758",
      "dateStarted": "2019-04-10 15:23:53.514",
      "dateFinished": "2019-04-10 15:23:53.528",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Apply Multi-input heuristic",
      "text": "//val txGraph \u003d session.readFrom(\"bolt://localhost:7687\").asCaps.cache\n\nval neo4jConfig \u003d Neo4jConfig(URI.create(\"bolt://localhost:7687\"), user \u003d \"neo4j\", password \u003d Some(\"password\"), encrypted \u003d  false)\n//val neo4jConfig \u003d Neo4jConfig(URI.create(\"bolt://localhost:7687\"), \"neo4j\", password \u003d Some(\"password\"), false)\n//val neo4jNamespace \u003d Namespace(\"txGraph\")\n//val neo4jSource \u003d GraphSources.cypher.neo4j(neo4j.config)\n\n//caps.catalog.register\n\n\n// Connect to a Neo4j instance and populate it with social network data\n  // To run a test instance you may use\n  //  ./gradlew :okapi-neo4j-io-testing:neo4jStart\n  //  ./gradlew :okapi-neo4j-io-testing:neo4jStop\n//val neo4j \u003d connectNeo4j(personNetwork)\n\n// Register Property Graph Data Sources (PGDS)\n//session.registerSource(Namespace(\"txGraph\"), GraphSources.cypher.neo4j(txSource.config))\n//session.registerSource(Namespace(\"txGraph\"), GraphSources.cypher.neo4j(neo4jConfig))\n\n// Access the graphs via their qualified graph names\n//val txGraph \u003d session.catalog.graph(\"txGraph.graph\")\nsession.catalog.register(Namespace(\"txGraph\"), GraphSources.cypher.neo4j(neo4jConfig))\n\n// Query for multi-inputs and create new edges between addresses that belong together\n//  val addressGraph \u003d txGraph.cypher(\n    val addressGraph \u003d session.cypher(\n    \"\"\"|FROM GRAPH txGraph.graph\n       |MATCH (a1:Address)-[:SENDS]-\u003e(t)\u003c-[:SENDS]-(a2:Address)\n       |CONSTRUCT\n       |  CREATE (a1)-[:IS_SAME]-\u003e(a2)\n       |RETURN GRAPH\n    \"\"\".stripMargin).graph\n\n// Use the Neo4jGraphMerge utility to write the products and the recommendations back to Neo4j\n\n  // Define the node and relationship keys\n  // Note that in this example we assume that names and titles uniquely identify people and products\n//  val nodeKeys \u003d Map(\"Address\" -\u003e Set(\"address\"))\n\n  // Write the recommendations back to Neo4j\n//  Neo4jGraphMerge.merge(entireGraphName, addressGraph, neo4jConfig, Some(nodeKeys))\n  \n  // Clear Neo4j test instance and close session / driver\n  //neo4j.close()",
      "user": "anonymous",
      "dateUpdated": "2019-04-24 01:11:07.434",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/scala",
        "title": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "ERROR",
        "msg": [
          {
            "type": "TEXT",
            "data": "[WARN ] 2019-04-24 01:11:13.127 [pool-2-thread-3] SchemaFromProcedure$ - Neo4j schema procedure not activated. Consider activating the procedure `org.opencypher.okapi.procedures.schema`.\norg.opencypher.okapi.impl.exception.UnsupportedOperationException: Neo4j PGDS requires okapi-neo4j-procedures to be installed in Neo4j:\n\thttps://github.com/opencypher/cypher-for-apache-spark/wiki/Neo4j-Schema-Procedure\n  at org.opencypher.spark.api.io.neo4j.AbstractNeo4jDataSource.readSchema(AbstractNeo4jDataSource.scala:48)\n  at org.opencypher.spark.api.io.neo4j.Neo4jPropertyGraphDataSource.org$opencypher$spark$api$io$neo4j$Neo4jPropertyGraphDataSource$$super$readSchema(Neo4jPropertyGraphDataSource.scala:86)\n  at org.opencypher.spark.api.io.neo4j.Neo4jPropertyGraphDataSource$$anonfun$entireGraphSchema$1.apply(Neo4jPropertyGraphDataSource.scala:86)\n  at org.opencypher.spark.api.io.neo4j.Neo4jPropertyGraphDataSource$$anonfun$entireGraphSchema$1.apply(Neo4jPropertyGraphDataSource.scala:86)\n  at scala.Option.getOrElse(Option.scala:121)\n  at org.opencypher.spark.api.io.neo4j.Neo4jPropertyGraphDataSource.entireGraphSchema$lzycompute(Neo4jPropertyGraphDataSource.scala:86)\n  at org.opencypher.spark.api.io.neo4j.Neo4jPropertyGraphDataSource.entireGraphSchema(Neo4jPropertyGraphDataSource.scala:85)\n  at org.opencypher.spark.api.io.neo4j.Neo4jPropertyGraphDataSource.readSchema(Neo4jPropertyGraphDataSource.scala:92)\n  at org.opencypher.spark.api.io.AbstractPropertyGraphDataSource.schema(AbstractPropertyGraphDataSource.scala:141)\n  at org.opencypher.okapi.ir.impl.QueryLocalCatalog.schemaFromDataSource(QueryLocalCatalog.scala:64)\n  at org.opencypher.okapi.ir.impl.QueryLocalCatalog.schema(QueryLocalCatalog.scala:49)\n  at org.opencypher.okapi.ir.impl.IRBuilderContext.schemaFor(IRBuilderContext.scala:92)\n  at org.opencypher.okapi.ir.impl.IRBuilder$$anonfun$org$opencypher$okapi$ir$impl$IRBuilder$$convertClause$3.apply(IRBuilder.scala:175)\n  at org.opencypher.okapi.ir.impl.IRBuilder$$anonfun$org$opencypher$okapi$ir$impl$IRBuilder$$convertClause$3.apply(IRBuilder.scala:172)\n  at org.atnos.eff.Continuation.go$1(Continuation.scala:54)\n  at org.atnos.eff.Continuation.apply(Continuation.scala:72)\n  at org.atnos.eff.Interpret$$anonfun$interpretContinuation$1$1.apply(Interpret.scala:43)\n  at org.atnos.eff.Interpret$$anonfun$interpretContinuation$1$1.apply(Interpret.scala:43)\n  at org.atnos.eff.Continuation.go$1(Continuation.scala:54)\n  at org.atnos.eff.Continuation.apply(Continuation.scala:72)\n  at org.atnos.eff.Interpret$$anonfun$interpretContinuation$1$1.apply(Interpret.scala:43)\n  at org.atnos.eff.Interpret$$anonfun$interpretContinuation$1$1.apply(Interpret.scala:43)\n  at org.atnos.eff.Continuation.go$1(Continuation.scala:54)\n  at org.atnos.eff.Continuation.apply(Continuation.scala:72)\n  at org.atnos.eff.EffInterpretation$$anonfun$runEval$1$1.apply(Eff.scala:361)\n  at org.atnos.eff.EffInterpretation$$anonfun$runEval$1$1.apply(Eff.scala:361)\n  at cats.Later.value$lzycompute(Eval.scala:151)\n  at cats.Later.value(Eval.scala:150)\n  at cats.Eval$.loop$1(Eval.scala:351)\n  at cats.Eval$.cats$Eval$$evaluate(Eval.scala:372)\n  at cats.Eval$FlatMap.value(Eval.scala:308)\n  at org.atnos.eff.EffInterpretation$class.run(Eff.scala:369)\n  at org.atnos.eff.Eff$.run(Eff.scala:149)\n  at org.atnos.eff.syntax.EffNoEffectOps$.run$extension(eff.scala:59)\n  at org.opencypher.okapi.ir.impl.package$RichIRBuilderStack.run(package.scala:52)\n  at org.opencypher.okapi.ir.impl.IRBuilder$.process(IRBuilder.scala:55)\n  at org.opencypher.okapi.relational.api.graph.RelationalCypherSession$$anonfun$6.apply(RelationalCypherSession.scala:155)\n  at org.opencypher.okapi.relational.api.graph.RelationalCypherSession$$anonfun$6.apply(RelationalCypherSession.scala:155)\n  at org.opencypher.okapi.relational.api.graph.RelationalCypherSession.time(RelationalCypherSession.scala:105)\n  at org.opencypher.okapi.relational.api.graph.RelationalCypherSession.cypherOnGraph(RelationalCypherSession.scala:155)\n  at org.opencypher.okapi.relational.api.graph.RelationalCypherSession.cypher(RelationalCypherSession.scala:119)\n  ... 57 elided\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1554818722572_-627364244",
      "id": "20190409-160522_1379143450",
      "dateCreated": "2019-04-09 16:05:22.572",
      "dateStarted": "2019-04-24 01:11:07.464",
      "dateFinished": "2019-04-24 01:11:13.722",
      "status": "ERROR",
      "progressUpdateIntervalMs": 500
    },
    {
      "user": "anonymous",
      "config": {},
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "jobName": "paragraph_1554823045191_1329916810",
      "id": "20190409-171725_2047313327",
      "dateCreated": "2019-04-09 17:17:25.191",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    }
  ],
  "name": "AddressTest",
  "id": "2E9MJ9VAR",
  "noteParams": {},
  "noteForms": {},
  "angularObjects": {
    "neo4j:shared_process": [],
    "spark:shared_process": []
  },
  "config": {
    "isZeppelinNotebookCronEnable": false
  },
  "info": {}
}